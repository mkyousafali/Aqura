# GitHub Copilot Instructions for Aqura Management System

## ğŸ”„ Version Management Protocol

**CRITICAL: Every time you commit and push changes to git, you MUST update the version number.**

### Automatic Version Update Process:

1. **Before committing any changes**, run the version update script:
   ```bash
   # Use npm scripts (recommended)
   npm run version:patch    # For bug fixes and small improvements
   npm run version:minor    # For new features 
   npm run version:major    # For breaking changes
   
   # Or use direct script
   node scripts/update-version.js [patch|minor|major]
   ```
   This will automatically:
   - Increment version (2.0.2 â†’ 2.0.3)
   - Update root `package.json`
   - Update `frontend/package.json`
   - Update version display in `frontend/src/lib/components/Sidebar.svelte`
   - Update mobile version in `frontend/src/routes/mobile/+layout.svelte`

2. **Update version popup content manually** (REQUIRED):
   - Edit `frontend/src/lib/components/Sidebar.svelte` (lines ~610-650)
   - Update feature descriptions to match your changes
   - Update release date and version info
   - Use specific action words: "Fixed", "Implemented", "Enhanced", "Added"

3. **Then proceed with git operations**:
   ```bash
   git add -A
   git commit -m "feat: your feature description"
   git push origin master
   ```

### Version Update Guidelines:

- **Patch (x.x.X)**: Bug fixes, small improvements, styling changes, documentation updates
- **Minor (x.X.0)**: New features, component additions, significant enhancements, new modules
- **Major (X.0.0)**: Breaking changes, major architecture changes, API changes, complete rewrites

### Files That Display Version:

- `frontend/src/lib/components/Sidebar.svelte` - Desktop version footer and popup content
- `frontend/src/routes/mobile/+layout.svelte` - Mobile top bar version badge
- `package.json` - Root project version
- `frontend/package.json` - Frontend project version

### Integration Points:

The version number appears in:
1. **Desktop Sidebar Footer**: Shows version as "v2.0.2" with clickable popup
2. **Mobile Header Badge**: Shows version badge in top navigation
3. **Package Metadata**: Used for builds and deployments
4. **Version Popup**: Detailed release notes and feature descriptions

### Copilot Workflow Checklist:

Before every `git push`:
- [ ] Run `npm run version:[patch|minor|major]`
- [ ] Update version popup content in Sidebar.svelte
- [ ] Verify version updated in all 4 locations
- [ ] Test version display in both desktop and mobile interfaces
- [ ] Commit version changes with descriptive message
- [ ] Push to remote repository

### Error Handling:

If version update script fails:
1. Check if all target files exist
2. Verify file permissions
3. Ensure valid JSON syntax in package.json files
4. Check for merge conflicts in target files

### Manual Version Update (Fallback):

If script fails, manually update these files:
1. `/package.json` - "version" field
2. `/frontend/package.json` - "version" field  
3. `/frontend/src/lib/components/Sidebar.svelte` - Version footer and popup content
4. `/frontend/src/routes/mobile/+layout.svelte` - Mobile version badge

---

## âš ï¸ Important: Always Confirm Before Making Changes

**CRITICAL RULE: NEVER assume or make changes without explicit confirmation from the user.**

### Before Making ANY Changes:
1. **Analyze the request thoroughly** - Understand what the user is asking for
2. **Check existing implementation** - Review current code, database schema, and structure
3. **Identify potential impacts** - Consider what will be affected by the change
4. **Present a clear plan** - Explain what you will change and why
5. **WAIT for user confirmation** - Do not proceed until the user explicitly approves

### What Requires Confirmation:
- âœ‹ **Database changes** (schema, functions, triggers, RLS policies)
- âœ‹ **File creation/deletion** (new components, utilities, routes)
- âœ‹ **Code modifications** (logic changes, refactoring, optimizations)
- âœ‹ **Configuration updates** (package.json, vite.config, tailwind.config)
- âœ‹ **Architectural decisions** (new patterns, state management, API structure)
- âœ‹ **Version updates** (dependencies, framework versions)
- âœ‹ **Build/deployment changes** (build scripts, deployment config)

### Code Quality Checks:

**CRITICAL: After making ANY code edits, ALWAYS verify correctness.**

#### 1. Translation Update Protocol:

**CRITICAL: When adding ANY new UI elements (buttons, labels, menus, messages), ALWAYS update translations.**

1. **Files to Update**:
   - âœ… `frontend/src/lib/i18n/locales/en.ts` - English translations
   - âœ… `frontend/src/lib/i18n/locales/ar.ts` - Arabic translations (RTL)

2. **When Translation is Required**:
   - âœ… New sidebar menu items or buttons
   - âœ… New window titles or component labels
   - âœ… User-facing messages (success, error, warnings)
   - âœ… Form labels, placeholders, and validation messages
   - âœ… Modal dialogs and confirmation messages
   - âœ… Status indicators and tooltips
   - âœ… Navigation items and breadcrumbs

3. **Translation Best Practices**:
   - Add translations in **both** English and Arabic files
   - Use descriptive keys that match the feature context
   - Keep translations concise and user-friendly
   - Use proper Arabic grammar and cultural context
   - Add comments to organize translation sections

4. **Example Translation Addition**:
   ```typescript
   // English (en.ts)
   reports: {
     expenseTracker: "Expense Tracker",
     salesReport: "Sales Report",  // â† Add new translation
   },
   
   // Arabic (ar.ts)
   reports: {
     expenseTracker: "ØªØªØ¨Ø¹ Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª",
     salesReport: "ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª",  // â† Add new translation
   },
   ```

5. **Verification Checklist**:
   - [ ] Translation added to `en.ts` file
   - [ ] Translation added to `ar.ts` file
   - [ ] Translation key matches usage in component
   - [ ] Arabic translation is culturally appropriate
   - [ ] No syntax errors in locale files
   - [ ] Test UI in both English and Arabic modes

#### 2. Syntax Error Prevention Protocol:
1. **After every `replace_string_in_file` operation** - Check for:
   - âœ… Matching opening and closing brackets `{}`, `[]`, `()`
   - âœ… Proper closing of functions, objects, and arrays
   - âœ… No duplicate closing statements (e.g., `}));` appearing twice)
   - âœ… Correct template literal syntax in Svelte components
   - âœ… Proper JSX/Svelte syntax (no unclosed tags)
   
2. **Use `get_errors` tool immediately after editing** - Verify no compile errors:
   ```
   Use get_errors tool to check the edited file for syntax/compile errors
   ```

3. **Common Syntax Pitfalls to Avoid**:
   - âŒ Duplicate closing brackets when copy-pasting code
   - âŒ Missing commas in object/array literals
   - âŒ Unclosed template literals or strings
   - âŒ Missing semicolons in statement termination (where required)
   - âŒ Incorrect arrow function syntax `() => {}`
   - âŒ Mismatched JSX/Svelte tag closures

4. **If Syntax Error Detected**:
   - Immediately fix the error before proceeding
   - Re-verify with `get_errors` tool
   - Inform user of the fix made

5. **Best Practice**:
   - Read surrounding context before editing (3-5 lines before/after)
   - Count brackets in your replacement strings
   - Preview the full logical block being modified
   - Test compile after each significant change

#### 3. Import Error Prevention Protocol:

**CRITICAL: NEVER assume import paths or module names. ALWAYS verify before adding imports.**

1. **Before Adding ANY Import Statement**:
   - âœ… Use `file_search` to find the actual file/module location
   - âœ… Check existing imports in similar files
   - âœ… Use `grep_search` to find how the module is imported elsewhere
   - âœ… Verify the export name matches what you're importing
   
2. **Common Import Verification Steps**:
   ```bash
   # Find the store/module file
   file_search: **/*notification*.{ts,js,svelte}
   
   # Check how it's used in other files
   grep_search: "import.*notification" (isRegexp: true)
   
   # Read the actual file to see exports
   read_file: path/to/notification/file.ts
   ```

3. **Import Path Patterns in Aqura**:
   - âœ… `$lib/stores/notifications` - Notification store (uses .add() method)
   - âœ… `$lib/stores/windowManager` - Window management store
   - âœ… `$lib/i18n` - Bilingual translation system
   - âœ… `$lib/utils/supabase` - Supabase client utilities
   - âœ… `$lib/components/*` - UI components
   - âŒ `$lib/stores/notificationStore` - DOES NOT EXIST
   - âŒ `$lib/utils/notifications` - WRONG PATH

4. **Common Import Mistakes to Avoid**:
   - âŒ Importing non-existent modules (e.g., `notificationStore`)
   - âŒ Using wrong import names (e.g., `showNotification` instead of `notifications`)
   - âŒ Mixing default and named imports incorrectly
   - âŒ Using relative paths instead of `$lib` alias
   - âŒ Assuming a utility exists without checking
   - âŒ Copy-pasting imports from other projects

5. **Verification Checklist Before Importing**:
   - [ ] File/module actually exists in codebase
   - [ ] Export name matches import statement
   - [ ] Import path is correct (use $lib alias)
   - [ ] Method names match the actual API
   - [ ] Dependencies are installed (check package.json)

6. **If Import Error Detected**:
   - Stop immediately - do NOT guess the correct path
   - Use `file_search` to locate the actual module
   - Use `grep_search` to find working examples
   - Read the actual file to verify exports
   - Update import with verified path and name
   - Test with `get_errors` tool

7. **Store/Module Usage Patterns**:
   ```javascript
   // âœ… CORRECT - Notifications Store
   import { notifications } from '$lib/stores/notifications';
   notifications.add({ message: 'Success!', type: 'success' });
   
   // âœ… CORRECT - Window Manager
   import { openWindow } from '$lib/stores/windowManager';
   openWindow('ComponentName', { props });
   
   // âœ… CORRECT - i18n System
   import { t, isRTL } from '$lib/i18n';
   $t('key.path')
   
   // âœ… CORRECT - Supabase
   import { supabaseAdmin } from '$lib/utils/supabase';
   const { data, error } = await supabaseAdmin.from('table').select();
   
   // âŒ WRONG - Non-existent modules
   import { showNotification } from '$lib/stores/notificationStore'; // DOES NOT EXIST
   import notifications from '$lib/utils/notifications'; // WRONG PATH
   ```

8. **Best Practice Workflow**:
   ```
   Step 1: Need to use functionality X
   Step 2: Search for existing usage: grep_search("import.*X", true)
   Step 3: Find the file: file_search("**/*X*.{ts,js}")
   Step 4: Read exports: read_file(found_path)
   Step 5: Copy exact import from working example
   Step 6: Verify with get_errors tool
   ```

#### 4. Method/API Error Prevention Protocol:

**CRITICAL: After importing a module, verify its actual API before using it.**

1. **Before Calling ANY Method**:
   - âœ… Read the source file to see available methods
   - âœ… Check method signatures (parameters, return types)
   - âœ… Look for existing usage examples in codebase
   - âœ… Verify method name spelling exactly

2. **Common API Verification Steps**:
   ```javascript
   // After importing notifications store, verify its API:
   // 1. Read the store file
   read_file: frontend/src/lib/stores/notifications.ts
   
   // 2. Look for method definitions:
   //    - add() method?
   //    - show() method?
   //    - notify() method?
   //    - What parameters does it accept?
   ```

3. **Method Call Patterns in Aqura**:
   - âœ… `notifications.add({ message, type, duration })` - Add notification
   - âœ… `openWindow('Component', { props })` - Open window
   - âœ… `$t('translation.key')` - Get translation
   - âŒ `showNotification({ message })` - DOES NOT EXIST
   - âŒ `notifications.show()` - WRONG METHOD NAME

4. **Verification Checklist Before Method Calls**:
   - [ ] Method exists on the imported object
   - [ ] Method name is spelled correctly
   - [ ] Parameters match expected signature
   - [ ] Return value is handled correctly
   - [ ] Async/await used where needed

#### 5. Saudi Arabia Timezone Handling Protocol:

**CRITICAL: Saudi Arabia uses UTC+3 timezone. ALWAYS convert datetime inputs to/from UTC.**

1. **Datetime Input Fields (datetime-local)**:
   - Display dates in Saudi timezone (UTC+3) for user convenience
   - Convert to UTC before saving to database
   - Convert from UTC when loading from database
   
2. **Required Helper Functions**:
   ```javascript
   // Convert UTC to Saudi time for datetime-local input display
   function toSaudiTimeInput(utcDateString: string) {
     const date = new Date(utcDateString);
     const saudiTime = new Date(date.toLocaleString('en-US', { timeZone: 'Asia/Riyadh' }));
     const year = saudiTime.getFullYear();
     const month = String(saudiTime.getMonth() + 1).padStart(2, '0');
     const day = String(saudiTime.getDate()).padStart(2, '0');
     const hours = String(saudiTime.getHours()).padStart(2, '0');
     const minutes = String(saudiTime.getMinutes()).padStart(2, '0');
     return `${year}-${month}-${day}T${hours}:${minutes}`;
   }

   // Convert Saudi time from datetime-local input to UTC for database storage
   function toUTCFromSaudiInput(saudiTimeString: string) {
     const [datePart, timePart] = saudiTimeString.split('T');
     const [year, month, day] = datePart.split('-').map(Number);
     const [hours, minutes] = timePart.split(':').map(Number);
     
     // Create date in Saudi timezone (UTC+3)
     const saudiDate = new Date(year, month - 1, day, hours, minutes);
     
     // Convert to UTC by subtracting 3 hours
     const utcDate = new Date(saudiDate.getTime() - (3 * 60 * 60 * 1000));
     
     return utcDate.toISOString();
   }
   ```

3. **When Loading Data from Database**:
   ```javascript
   // âœ… CORRECT - Convert UTC to Saudi time for display
   offerData = {
     name_ar: data.name_ar,
     start_date: toSaudiTimeInput(data.start_date),  // Convert to Saudi time
     end_date: toSaudiTimeInput(data.end_date)
   };
   ```

4. **When Saving Data to Database**:
   ```javascript
   // âœ… CORRECT - Convert Saudi time to UTC for storage
   const offerPayload = {
     name_ar: offerData.name_ar,
     start_date: toUTCFromSaudiInput(offerData.start_date),  // Convert to UTC
     end_date: toUTCFromSaudiInput(offerData.end_date)
   };
   ```

5. **Common Timezone Mistakes to Avoid**:
   - âŒ Saving datetime-local value directly without UTC conversion
   - âŒ Displaying UTC time directly in datetime-local input
   - âŒ Forgetting that datetime-local is in local timezone (Saudi time)
   - âŒ Assuming server and client are in same timezone
   - âŒ Using `new Date()` without timezone consideration

6. **When to Use Timezone Conversion**:
   - âœ… **ALWAYS** for datetime-local inputs in forms
   - âœ… **ALWAYS** when saving/loading start_date, end_date, scheduled times
   - âœ… **ALWAYS** for offer validity periods
   - âœ… **ALWAYS** for task due dates
   - âœ… **ALWAYS** for scheduled notifications

7. **Testing Timezone Correctness**:
   ```javascript
   // After saving, verify the stored UTC time is correct
   // Saudi time 9:00 PM (21:00) should be stored as 6:00 PM (18:00) UTC
   console.log('Input Saudi time:', saudiTimeString);  // 2025-11-12T21:00
   console.log('Stored UTC time:', utcISOString);      // 2025-11-12T18:00:00.000Z
   ```

8. **Impact of Incorrect Timezone Handling**:
   - âŒ Offers scheduled for wrong times (3 hours off)
   - âŒ Offers showing as "scheduled" when they should be "active"
   - âŒ Offers disappearing from lists due to status calculation errors
   - âŒ Tasks due at wrong times
   - âŒ Notifications sent at wrong times

### Exceptions (Can proceed without confirmation):
- âœ… **Reading files** to gather context
- âœ… **Searching codebase** to understand structure
- âœ… **Checking database schema** using utility scripts
- âœ… **Providing information** or explanations
- âœ… **Suggesting solutions** without implementing them

### Communication Pattern:
```
User: "Add a new feature X"

Copilot Response:
"I'll help you add feature X. Let me first check the current implementation...

[After checking]

Here's my plan:
1. Create new component at src/lib/components/X.svelte
2. Add route at src/routes/x/+page.svelte
3. Update windowManager.ts to include new window type
4. Add i18n translations for Arabic/English

This will affect:
- Window system (new window type)
- Routing (new route)
- i18n files (new translations)

Should I proceed with this implementation?"

[WAIT FOR USER: "yes" / "proceed" / "go ahead"]
```

### Communication Style for Summaries:
When summarizing work or providing updates to users:
- âœ… **Keep it brief and conversational** - Use simple, friendly language
- âœ… **Focus on what was accomplished** - Describe the outcome, not the technical details
- âœ… **Use bullet points** - Easy to scan and understand
- âœ… **Avoid code snippets** - Unless specifically requested by the user
- âœ… **Be human and relatable** - "Fixed the issue where offers were disappearing" instead of "Modified RLS policy execution"
- âœ… **Highlight user benefits** - "Now you can see and manage paused offers" instead of "Implemented reactive filtering"

### Never Assume:
- âŒ Don't assume column names exist in database tables - CHECK FIRST
- âŒ Don't assume functions or triggers exist - VERIFY using utility scripts
- âŒ Don't assume file structure - LIST directories if unsure
- âŒ Don't assume dependencies are installed - CHECK package.json
- âŒ Don't assume user wants a specific implementation - ASK for preferences
- âŒ Don't assume backwards compatibility is not needed - CONFIRM breaking changes

### Terminal Commands:
- **ALWAYS use PowerShell commands** - The development environment is VS Code on Windows with PowerShell
- Use PowerShell syntax: `Remove-Item`, `Copy-Item`, `Get-ChildItem`, etc.
- NOT bash/Linux commands: avoid `rm`, `cp`, `ls`, etc.
- Use semicolons (`;`) to chain commands on a single line if needed
- Use `2>$null` to suppress error output in PowerShell

### Git Workflow:
- **ALWAYS check git status before push** - Use `git status` to review staged and unstaged changes
- Review what files will be committed before pushing
- Ensure no unintended files are staged (e.g., .env, node_modules, build artifacts)
- Verify commit message follows conventional commits format
- Check for any merge conflicts before pushing

```powershell
# Recommended git workflow
git status                           # Check current status
git add -A                          # Stage all changes (after review)
git status                          # Verify staged changes
git commit -m "feat: description"   # Commit with conventional format
git status                          # Confirm clean working tree
git push origin master              # Push to remote
```

---

## ğŸ¯ Project Context

### Current Status: v2.0.2
- **Phase**: Development - Frontend foundation completed
- **Focus**: PWA-first windowed management platform for Saudi businesses
- **Target**: Bilingual (Arabic/English) enterprise management system

### Architecture:
- **Frontend**: SvelteKit + TypeScript + TailwindCSS + Vite PWA
- **Backend**: Go (Fiber framework) + Supabase (PostgreSQL + Auth + Storage)  
- **Deployment**: Vercel (Frontend) + Supabase (Backend)
- **Build Tools**: pnpm monorepo + Vite + PWA + Electron packaging
- **Package Manager**: pnpm (required - NOT npm/yarn)

### Development Environment:
```bash
# Install dependencies
pnpm setup  # or pnpm install

# Development servers  
pnpm dev  # Runs both frontend and backend
pnpm --filter frontend dev  # Frontend only (port 5173)

# Build commands
pnpm build  # Build all
pnpm build:pwa  # PWA build
pnpm build:windows  # Windows installer

# Utility commands
pnpm lint  # Lint all packages
pnpm test  # Run all tests  
pnpm i18n:extract  # Extract i18n strings
```

### Key Features Implemented:
- âœ… **Windowed Desktop Interface**: Drag/resize/minimize windows, taskbar, command palette
- âœ… **PWA Capabilities**: Installable, offline-first, service worker, push notifications
- âœ… **Bilingual System**: Arabic/English with RTL support and cultural adaptations
- âœ… **Business Modules**: 
  - HR Management (employees, departments, positions, salary)
  - Branch Management (multi-branch operations)
  - Vendor Management (vendor details, payment schedules, visits)
  - Receiving Management (receiving records, tasks, workflow)
  - Task System (assignments, completion tracking, reminders)
  - Customer Management (registration, login, recovery)
  - Finance Management (expenses, requisitions, payments)
  - Notification System (push notifications, in-app notifications)
- âœ… **Accessibility**: WCAG 2.1 compliant, screen reader support, keyboard navigation
- âœ… **Security**: Supabase RLS, JWT auth, encrypted transmission

### Key Components:
- **Window Manager** (`windowManager`) - Desktop-style window management system
- **Sidebar Navigation** - Multi-level navigation with submenus and role-based access
- **i18n System** - Custom bilingual localization (not auto-translate)
- **PWA Features** - Service worker, offline support, installation, push notifications
- **Data Management** - Supabase integration with real-time updates
- **User Management** - Role-based access control with position-based permissions
- **Task Management** - Full task workflow with assignments, completion, and tracking
- **Notification Center** - In-app notifications with attachments and read states
- **Receiving System** - Complete receiving workflow with role-specific tasks
- **My Tasks View** - Personal task dashboard with smooth UI updates
- **Cashier Interface** - Standalone desktop-style coupon redemption system with dedicated sidebar, taskbar, and window management

### UI/UX Guidelines:
- **Desktop-First**: Windowed interface with OS-style interactions
- **Mobile Responsive**: Touch-friendly mobile layouts
- **Bilingual**: Arabic RTL + English LTR with cultural adaptations
- **Accessibility**: ARIA labels, keyboard navigation, screen reader support
- **Color System**: Brand colors with consistent theming
- **Typography**: Noto Sans Arabic + Inter fonts

### Code Style Guidelines:
- **TypeScript**: Use for type safety, balanced typing (strict for domain, relaxed for UI)
- **Svelte Patterns**: Follow reactive patterns with Svelte stores
- **Error Handling**: Implement proper error handling with user feedback
- **Loading States**: Add loading states and user feedback for all async operations
- **Accessibility**: Use semantic HTML, ARIA labels, and keyboard navigation
- **Modularity**: Keep functions focused and modular
- **i18n**: Use custom i18n system (`import { t } from '$i18n'`)
- **Responsive**: Mobile-first responsive design with touch support

### Database Schema (Supabase):

**CRITICAL: ALWAYS CHECK DATABASE DIRECTLY - NEVER ASSUME SCHEMA**

**Why Direct Database Verification is Required:**
- SQL migration files have been removed from the repository
- Database schema is managed directly in Supabase
- Schema may change without local file updates
- Real-time verification prevents errors and assumptions

**How to Check Table Structure (JavaScript with Service Role Key):**

```javascript
// ALWAYS use this pattern to check table structure before working with any table
import { readFileSync } from 'fs';
import { createClient } from '@supabase/supabase-js';

// Load environment variables from frontend/.env
const envPath = './frontend/.env';
const envContent = readFileSync(envPath, 'utf-8');
const envVars = {};

envContent.split('\n').forEach(line => {
  const trimmed = line.trim();
  if (trimmed && !trimmed.startsWith('#')) {
    const match = trimmed.match(/^([^=]+)=(.*)$/);
    if (match) {
      envVars[match[1].trim()] = match[2].trim();
    }
  }
});

const supabaseUrl = envVars.VITE_SUPABASE_URL;
const supabaseServiceKey = envVars.VITE_SUPABASE_SERVICE_ROLE_KEY; // Use service role for full access

const supabase = createClient(supabaseUrl, supabaseServiceKey);

// Example: Check table structure and data
async function checkTable(tableName) {
  const { data, error, count } = await supabase
    .from(tableName)
    .select('*', { count: 'exact' })
    .limit(2);

  if (error) {
    console.error(`âŒ Error: ${error.message}`);
    return;
  }

  console.log(`ğŸ“Š Table: ${tableName}`);
  console.log(`   Total records: ${count}`);
  
  if (data && data.length > 0) {
    console.log(`   Columns:`, Object.keys(data[0]));
    console.log(`   Sample:`, JSON.stringify(data[0], null, 2));
  }
}

// Check specific table
await checkTable('offers');
```

**Environment Variables** (from `frontend/.env` file):
- `VITE_SUPABASE_URL` - Supabase project URL
- `VITE_SUPABASE_ANON_KEY` - Public anon key (limited access)
- `VITE_SUPABASE_SERVICE_ROLE_KEY` - Service role key (full database access, check schema)

**Database Summary:**
- **Total Tables: 71** (Customer-specific offers removed)
- Tables are organized by category: HR, Tasks, Receiving, Notifications, Finance, Customer, Product, Offers, System
- Use the verification script above to check any table's current structure before working with it

### Entity Types: Understanding users vs employees vs customers

**CRITICAL**: The Aqura system has THREE distinct entity types that serve different purposes and should NOT be confused:

#### 1. **USERS** (`users` table - UUID id)
- **Purpose**: Admin/Manager staff who operate the DESKTOP admin interface
- **Interface**: Desktop windowed management system (main Aqura interface)
- **Capabilities**: 
  - Create and manage offers, tasks, and business operations
  - Access all admin features and management tools
  - Assign offers to customers, manage employee records
  - Full system administration and configuration
- **Authentication**: Supabase Auth with role-based permissions
- **Usage Examples**:
  - `offers.created_by` â†’ References admin user who created the offer
  - `tasks.created_by` â†’ References admin user who created the task
  - `notifications.created_by` â†’ References admin user who sent the notification
- **Database Relations**: Primary operators of the system with highest permissions

#### 2. **EMPLOYEES** (`hr_employees` table - UUID id)
- **Purpose**: Company staff/workers tracked in the HR management system
- **Interface**: Managed through Desktop HR module (not direct system users)
- **Capabilities**:
  - Tracked for payroll, attendance, department assignments
  - Managed by admins through HR interface
  - May or may not have user accounts (separate from users table)
  - Subject to HR policies, salary components, position assignments
- **Authentication**: NOT directly authenticated (managed entities, not system users)
- **Usage Examples**:
  - `hr_employees.id` â†’ Employee records for HR purposes
  - `hr_position_assignments.employee_id` â†’ Position tracking
  - `hr_salary_components.employee_id` â†’ Salary management
  - `expense_requisitions.employee_id` â†’ Employee expense requests
- **Database Relations**: HR system entities, MAY have corresponding users table entry if given admin access
- **Key Distinction**: Employees are HR records; users are system operators. An employee might become a user if granted admin access, but most employees are NOT users.

#### 3. **CUSTOMERS** (`customers` table - UUID id)
- **Purpose**: End users/shoppers who use the MOBILE customer app
- **Interface**: Mobile customer-facing application (shopping, orders, offers)
- **Capabilities**:
  - Browse products and place orders
  - Receive and use offers/promotions
  - Track order history and delivery
  - Manage personal profile and preferences
- **Authentication**: Separate customer authentication system (access codes, mobile registration)
- **Usage Examples**:
  - `offer_usage_logs.customer_id` â†’ Customer who used an offer
  - `orders.customer_id` â†’ Customer who placed the order (when orders table exists)
  - `customer_recovery_requests.customer_id` â†’ Customer account recovery
- **Database Relations**: Mobile app users with limited, customer-facing permissions

#### Summary Table:

| Aspect | USERS | EMPLOYEES | CUSTOMERS |
|--------|-------|-----------|-----------|
| **ID Type** | UUID | UUID | UUID |
| **Table** | `users` | `hr_employees` | `customers` |
| **Interface** | Desktop Admin | Managed by Admin | Mobile App |
| **Purpose** | System operators | HR records | End shoppers |
| **Auth Type** | Supabase Auth | No direct auth | Customer auth |
| **Permissions** | Full admin access | Managed entities | Limited customer access |
| **Can Create Offers?** | âœ… Yes | âŒ No | âŒ No |
| **Can Receive Offers?** | âŒ No | âŒ No | âœ… Yes |
| **Can Place Orders?** | âŒ No | âŒ No | âœ… Yes |
| **In HR System?** | Maybe (if also employee) | âœ… Yes | âŒ No |

#### Common Mistakes to Avoid:
- âŒ **Don't confuse** `users` with `employees` - they serve different purposes
- âŒ **Don't assume** all employees have user accounts (most don't)
- âŒ **Don't use** `hr_employees` table for offer assignments (use `customers` table)
- âŒ **Don't reference** `employees` in customer-facing features (use `customers` table)
- âŒ **Don't mix** admin operations (`users`) with customer operations (`customers`)

#### When Creating New Features:
- **Admin/Manager Actions** â†’ Use `users` table (created_by, assigned_by, managed_by)
- **Customer-Facing Features** â†’ Use `customers` table (customer_id, user_id in customer context)
- **HR Operations** â†’ Use `hr_employees` table (employee_id for payroll, attendance, positions)
- **Cross-Reference Check**: Always verify which entity type is appropriate for your use case

**Total Tables: 65**

Core tables by category:

**User & Authentication:**
- `users` - User accounts and profiles with RLS
- `user_roles` - User role assignments
- `user_sessions` - Active user sessions
- `user_device_sessions` - Device-specific sessions
- `user_password_history` - Password change history
- `user_audit_logs` - User activity audit trail
- `role_permissions` - Role-based permissions
- `interface_permissions` - UI permission controls

**HR Management (11 tables):**
- `hr_employees` - Employee records (203 records)
- `hr_departments` - Department structure
- `hr_positions` - Position definitions
- `hr_position_assignments` - Employee-position mapping
- `hr_levels` - Hierarchical levels
- `hr_salary_components` - Salary breakdown
- `hr_salary_wages` - Wage information
- `hr_employee_contacts` - Employee contact details
- `hr_employee_documents` - Document management
- `hr_fingerprint_transactions` - Attendance tracking
- `hr_position_reporting_template` - Reporting structure

**Task Management (13 tables):**
- `tasks` - Main task system with assignments
- `task_assignments` - Task-user assignments
- `task_completions` - Task completion records
- `task_images` - Task attachments
- `task_reminder_logs` - Reminder history
- `receiving_tasks` - Receiving-specific tasks
- `receiving_task_templates` - Task templates
- `quick_tasks` - Quick task creation
- `quick_task_assignments` - Quick task assignments
- `quick_task_comments` - Task comments
- `quick_task_completions` - Quick task completions
- `quick_task_files` - Quick task attachments
- `quick_task_user_preferences` - User preferences
- `recurring_assignment_schedules` - Recurring task schedules
- `recurring_schedule_check_log` - Schedule execution log

**Receiving & Vendor (3 tables):**
- `receiving_records` - Receiving transaction data (755 records)
- `vendors` - Vendor information
- `vendor_payment_schedule` - Payment schedules

**Notifications (6 tables):**
- `notifications` - System notifications
- `notification_queue` - Push notification queue
- `notification_attachments` - Notification attachments
- `notification_recipients` - Notification recipients
- `notification_read_states` - Read status tracking
- `push_subscriptions` - Web push subscriptions

**Finance & Expenses (7 tables):**
- `expense_requisitions` - Expense requests
- `expense_parent_categories` - Main categories
- `expense_sub_categories` - Sub categories
- `expense_scheduler` - Scheduled expenses
- `employee_warnings` - Employee warnings
- `employee_warning_history` - Warning history
- `employee_fine_payments` - Fine payment tracking
- `non_approved_payment_scheduler` - Pending payments

**Customer Management (5 tables):**
- `customers` - Customer accounts
- `customer_recovery_requests` - Account recovery
- `customer_access_code_history` - Access code history
- `customer_app_media` - Customer media content
- `delivery_service_settings` - Delivery configuration
- `delivery_fee_tiers` - Delivery fee structure

**Product Management (4 tables):**
- `products` - Product catalog
- `product_categories` - Product categories
- `product_units` - Measurement units
- `tax_categories` - Tax definitions

**Offer System (6 tables - NORMALIZED STRUCTURE):**
- `offers` - Main offer metadata (cleaned - no redundant columns)
  - Core fields only: id, type, names, dates, limits, settings
  - All offer-specific data stored in child tables
- `offer_products` - Product-specific offers (percentage/special price)
  - Contains: product_id, offer_qty, offer_percentage, offer_price, max_uses
- `offer_bundles` - Bundle offer definitions
  - Contains: bundle_name, required_products (JSON array), discount_value
- `bogo_offer_rules` - Buy X Get Y offers
  - Contains: buy_product_id, buy_quantity, get_product_id, get_quantity, discount
- `offer_cart_tiers` - Cart-level discount tiers
  - Contains: tier_number, min_amount, max_amount, discount_type, discount_value
- `offer_usage_logs` - Usage tracking and limits enforcement
  - Contains: offer_id, customer_id, product_id, discount_applied, timestamp

**IMPORTANT NOTES:**
- âŒ `customer_offers` table has been REMOVED (not needed - offers are global)
- âœ… All redundant columns removed from `offers` table (2025-11-14 cleanup)
- âœ… Offer-specific data properly normalized into child tables
- âœ… Always query child tables for offer details (products, bundles, BOGO, tiers)

**System & Configuration (4 tables):**
- `branches` - Branch/location management
- `app_functions` - System functions
- `approval_permissions` - Approval workflows
- `requesters` - Request originators

### Database Functions (Supabase):
**Total Functions: 256** organized into 8 categories

Use `node list-functions.js` to see all functions by category.

**Key Functions by Category:**

**Task Management (59 functions)** - Task workflow and completion
- `complete_receiving_task_simple` - Complete receiving tasks with validation
- `create_quick_task_with_assignments` - Create and assign quick tasks
- `check_overdue_tasks_and_send_reminders` - Automated reminder system
- `validate_task_completion_requirements` - Ensure completion criteria met

**Receiving & Vendor (51 functions)** - Receiving workflow and vendor management
- `get_vendor_for_receiving_record` - Fetch vendor details for receiving
- `calculate_next_visit_date` - Auto-calculate vendor visit schedules
- `sync_erp_reference_for_receiving_record` - Sync ERP invoice references

**User Management (20 functions)** - Authentication and permissions
- `create_user` - User account creation with role assignment
- `verify_password` - Password verification and hashing
- `get_user_interface_permissions` - Retrieve UI permission set

**Employee/HR (10 functions)** - HR and employee management
- `sync_employee_with_hr` - Sync employee data with HR system
- `get_active_employees_by_branch` - Branch-specific employee lists

**Financial (16 functions)** - Payment and expense management
- `record_fine_payment` - Record employee fine payments
- `count_bills_without_pr_excel` - Track missing PR Excel files
- `validate_payment_methods` - Ensure valid payment method selection

**Notification (23 functions)** - Push and in-app notifications
- `queue_push_notification` - Queue notifications for delivery
- `process_push_notification_queue` - Process queued notifications
- `cleanup_orphaned_notifications` - Maintain notification hygiene

**Customer (12 functions)** - Customer account management
- `authenticate_customer_access_code` - Customer authentication
- `create_customer_registration` - New customer registration
- `process_customer_recovery` - Account recovery workflow

**System/ERP (31 functions)** - System utilities and ERP integration
- `get_database_schema` - Retrieve complete database schema
- `get_database_functions` - List all database functions
- `sync_all_missing_erp_references` - Batch sync ERP data
- `http_*` - HTTP utility functions for external API calls

### Database Triggers (Supabase):
**Total Triggers: 71** across 35 tables organized by function type

Use `node list-triggers.js` to see all triggers by table.

**Key Trigger Types:**

**Timestamp Management (Most tables):**
- `update_updated_at` - Auto-update timestamp on record changes
- Applied to most core tables for audit trails

**Auto-Calculations:**
- `calculate_receiving_amounts` - Auto-calculate amounts in receiving records
- `calculate_category_days` - Calculate expense category days
- `update_final_bill_amount_on_adjustment` - Recalculate bill amounts

**Synchronization:**
- `sync_user_roles_from_positions` - Sync roles when position changes
- `sync_requisition_balance` - Update balance on payment changes
- `sync_erp_reference` - Sync ERP invoice references

**Notifications:**
- `queue_push_notification_trigger` - Queue push notifications
- `create_quick_task_notification` - Notify on task creation
- `notify_expense_changes` - Alert on expense updates

**Audit & Logging:**
- `log_user_action` - Log all user actions (INSERT/UPDATE/DELETE on users table)
- `log_password_change` - Track password changes in history
- `track_access_code_changes` - Log customer access code updates

**Cleanup & Maintenance:**
- `cleanup_assignment_notifications` - Remove orphaned notification assignments
- `cleanup_task_notifications` - Clean up task-related notifications
- `delete_old_push_subscriptions` - Remove expired push subscriptions

**Tables with Most Triggers:**
- `expense_scheduler` - 8 triggers (scheduling, calculation, notification)
- `hr_employee_documents` - 6 triggers (status, workflow, validation)
- `employee_warnings` - 5 triggers (warning workflow, fine tracking)
- `users` - 5 triggers (audit, role sync, session management)

### Database Constraints:
**Note**: Constraint details should be checked directly in Supabase Dashboard or by inspecting individual tables.

**Utility Script**: Use `node check-table-structure.js [table_name]` to see column structure including:
- Primary keys (id columns with SERIAL/UUID types)
- Foreign key relationships (references to other tables)
- NOT NULL constraints (is_nullable field)
- Default values and data types

**Common Constraint Patterns:**
- **Primary Keys**: All tables have `id` as primary key (SERIAL or UUID)
- **Foreign Keys**: Consistent naming (`table_id` references `table.id`)
- **Timestamps**: `created_at` and `updated_at` with NOT NULL constraints
- **Branch Relations**: Most operational tables link to `branches.id`
- **User Relations**: Activity tables link to `users.id` for audit trails
- **Status Fields**: Use CHECK constraints for valid status values
- **Unique Constraints**: Applied to business identifiers (employee_id, erp_reference, etc.)

**Referential Integrity Examples:**
- `hr_employees.branch_id` â†’ `branches.id`
- `tasks.assigned_to` â†’ `users.id`
- `receiving_records.vendor_id` â†’ `vendors.id`
- `notifications.created_by` â†’ `users.id`
- `expense_requisitions.employee_id` â†’ `hr_employees.id`

### File Structure:
```
Aqura/
â”œâ”€â”€ frontend/               # SvelteKit PWA frontend
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”‚   â”œâ”€â”€ components/    # Reusable UI components
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ admin/     # Admin components (tasks, vendor, receiving, etc.)
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ coupon/
â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ cashier/  # Cashier interface components
â”‚   â”‚   â”‚   â”‚   â”‚           â”œâ”€â”€ CashierLogin.svelte      # Access code authentication
â”‚   â”‚   â”‚   â”‚   â”‚           â”œâ”€â”€ CashierInterface.svelte  # Standalone desktop interface
â”‚   â”‚   â”‚   â”‚   â”‚           â””â”€â”€ CouponRedemption.svelte  # Redemption window component
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ customer/  # Customer-facing components
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ shared/    # Shared components (buttons, modals, etc.)
â”‚   â”‚   â”‚   â”œâ”€â”€ stores/        # Svelte stores for state management
â”‚   â”‚   â”‚   â”œâ”€â”€ utils/         # Utility functions and helpers
â”‚   â”‚   â”‚   â”œâ”€â”€ types/         # TypeScript type definitions
â”‚   â”‚   â”‚   â””â”€â”€ i18n/          # Custom bilingual system (Arabic/English)
â”‚   â”‚   â”œâ”€â”€ routes/            # SvelteKit file-based routing
â”‚   â”‚   â”‚   â”œâ”€â”€ api/           # API endpoints (+server.js files)
â”‚   â”‚   â”‚   â”œâ”€â”€ mobile/        # Mobile-optimized interface
â”‚   â”‚   â”‚   â”œâ”€â”€ coupon/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ cashier/   # Cashier access code login route
â”‚   â”‚   â”‚   â””â”€â”€ +page.svelte   # Desktop windowed interface
â”‚   â”‚   â”œâ”€â”€ app.html           # HTML template
â”‚   â”‚   â””â”€â”€ app.css            # Global styles
â”‚   â”œâ”€â”€ static/                # Static assets (icons, sounds, manifest)
â”‚   â””â”€â”€ package.json           # Frontend dependencies
â”œâ”€â”€ supabase/                  # Supabase backend configuration
â”‚   â”œâ”€â”€ functions/             # Edge functions (push notifications, etc.)
â”‚   â”œâ”€â”€ migrations/            # Database migrations (SQL files removed)
â”‚   â””â”€â”€ config.toml            # Supabase configuration
â”œâ”€â”€ scripts/                   # Utility scripts
â”‚   â””â”€â”€ update-version.js      # Version management script
â”œâ”€â”€ build/                     # Production build output
â”œâ”€â”€ package.json               # Root workspace configuration
â””â”€â”€ pnpm-workspace.yaml        # pnpm monorepo configuration
```

### Important Conventions:
- **Database Schema**: ALWAYS check original schema, functions, triggers, constraints in Supabase using service role key before making changes
- **Service Role Key**: Use `SUPABASE_SERVICE_ROLE_KEY` from `.env` for direct database inspection
- **Schema Verification**: Never assume schema structure - query Supabase directly to verify
- **Commits**: Use conventional commits (`feat:`, `fix:`, `docs:`, `perf:`, etc.)
- **Branches**: Work on `master` branch (single developer workflow)
- **Imports**: Use `$lib` alias for library imports
- **Styling**: TailwindCSS with custom design system
- **State**: Use Svelte stores for global state management
- **API**: Use Supabase client for data operations with RLS policies
- **Routes**: SvelteKit file-based routing with `+page.svelte` and `+server.js`
- **Performance**: Batch database queries, use reactive updates instead of full reloads
- **UX**: Smooth transitions, optimistic UI updates, proper loading states

### Recent Optimizations:
- **NotificationCenter**: Batch loading for task attachments (single query vs sequential)
- **MyTasksView**: Smooth task removal without full page reload
- **Receiving Tasks**: Auto-flag upload states in API endpoints
- **Database**: Fixed upload flag inconsistencies for receiving records

Remember: Always maintain backward compatibility and provide migration paths for breaking changes!