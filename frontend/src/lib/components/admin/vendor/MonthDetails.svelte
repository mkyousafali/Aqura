<script>
	import { onMount } from 'svelte';
	import { supabase } from '$lib/utils/supabase';
	import { currentUser } from '$lib/utils/persistentAuth';

	// Helper function to format date as dd/mm/yyyy
	function formatDate(dateInput) {
		if (!dateInput) return 'N/A';
		const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = date.getFullYear();
		return `${day}/${month}/${year}`;
	}

	// Props passed from parent
	export let monthData = null;

	// Component state
	let monthDetailData = [];
	let scheduledPayments = [];
	
	// Filter state
	let filterBranch = '';
	let filterPaymentMethod = '';
	let branches = [];
	let paymentMethods = [];
	
	// Drag and drop state
	let draggedPayment = null;
	let showSplitModal = false;
	let splitPayment = null;
	let splitAmount = 0;
	let remainingAmount = 0;
	let newDateInput = '';

	// Edit payment method state
	let editingPaymentId = null;
	let showPaymentMethodModal = false;
	let editingPayment = null;

	// Initialize component
	onMount(async () => {
		if (monthData) {
			await loadBranches();
			await loadPaymentMethods();
			await loadScheduledPayments();
			generateAllDaysOfMonth(monthData);
		}
	});

	// Reactive statement to regenerate data when scheduledPayments change
	$: if (scheduledPayments.length >= 0 && monthData) {
		generateAllDaysOfMonth(monthData);
	}

	// Reactive statement to filter payments when filter changes
	$: filteredPayments = scheduledPayments.filter(payment => {
		if (filterBranch && payment.branch_name !== filterBranch) return false;
		if (filterPaymentMethod && payment.payment_method !== filterPaymentMethod) return false;
		return true;
	});

	// Regenerate data when filters change
	$: if (monthData && (filterBranch !== undefined || filterPaymentMethod !== undefined)) {
		generateAllDaysOfMonth(monthData);
	}

	// Calculate totals by payment method for the current month
	$: totalsByPaymentMethod = scheduledPayments.reduce((acc, payment) => {
		const paymentDate = new Date(payment.due_date);
		const currentMonth = monthData?.month;
		const currentYear = monthData?.year;
		
		// Only include payments from the current month/year
		if (currentMonth !== undefined && currentYear !== undefined && 
			paymentDate.getMonth() === currentMonth && paymentDate.getFullYear() === currentYear) {
			
			const method = payment.payment_method || 'Unknown';
			const amount = payment.final_bill_amount || 0;
			
			if (!acc[method]) {
				acc[method] = 0;
			}
			acc[method] += amount;
		}
		
		return acc;
	}, {});

	// Calculate total paid and unpaid amounts for the current month only
	$: {
		let totalScheduled = 0;
		let totalPaid = 0;
		let totalUnpaid = 0;
		
		// Calculate from scheduled payments for the current month
		const currentMonth = monthData?.month;
		const currentYear = monthData?.year;
		
		if (scheduledPayments && currentMonth !== undefined && currentYear !== undefined) {
			scheduledPayments.forEach(payment => {
				const paymentDate = new Date(payment.due_date);
				
				// Check if payment is in the current month/year
				if (paymentDate.getMonth() === currentMonth && paymentDate.getFullYear() === currentYear) {
					const amount = payment.final_bill_amount || 0;
					totalScheduled += amount;
					
					// Check if payment is paid (is_paid === true, not just truthy)
					if (payment.is_paid === true) {
						totalPaid += amount;
					} else {
						totalUnpaid += amount;
					}
				}
			});
		}
		
		totalPaidAmount = totalPaid;
		totalUnpaidAmount = totalUnpaid;
		
		// Update monthData.total with the calculated total for this month
		if (monthData) {
			monthData.total = totalScheduled;
		}
		
		// Debug logging
		console.log('Month totals:', { totalScheduled, totalPaid, totalUnpaid, monthTotal: monthData?.total });
	}

	let totalPaidAmount = 0;
	let totalUnpaidAmount = 0;

	// Load all branches from database
	async function loadBranches() {
		try {
			const { data, error } = await supabase
				.from('branches')
				.select('name_en, name_ar')
				.eq('is_active', true)
				.order('name_en', { ascending: true });

			if (error) {
				console.error('Error loading branches:', error);
				return;
			}

			branches = data?.map(b => b.name_en) || [];
			console.log('Loaded branches:', branches);
		} catch (error) {
			console.error('Error loading branches:', error);
		}
	}

	// Load all payment methods (you can customize this list)
	async function loadPaymentMethods() {
		try {
			// Get unique payment methods from vendor_payment_schedule
			const { data, error } = await supabase
				.from('vendor_payment_schedule')
				.select('payment_method');

			if (error) {
				console.error('Error loading payment methods:', error);
				// Fallback to default list
				paymentMethods = ['Cash on Delivery', 'Bank Credit'];
				return;
			}

			// Extract unique payment methods
			const methodSet = new Set();
			data?.forEach(payment => {
				if (payment.payment_method && payment.payment_method.trim() !== '') {
					methodSet.add(payment.payment_method.trim());
				}
			});

			paymentMethods = Array.from(methodSet).sort();
			console.log('Loaded payment methods:', paymentMethods);
		} catch (error) {
			console.error('Error loading payment methods:', error);
			// Fallback to default list
			paymentMethods = ['Cash on Delivery', 'Bank Credit'];
		}
	}

	// Extract unique branches and payment methods for filters
	function extractFilterOptions() {
		const branchSet = new Set();
		const paymentMethodSet = new Set();
		
		scheduledPayments.forEach(payment => {
			if (payment.branch_name && payment.branch_name.trim() !== '') {
				branchSet.add(payment.branch_name.trim());
			}
			if (payment.payment_method && payment.payment_method.trim() !== '') {
				paymentMethodSet.add(payment.payment_method.trim());
			}
		});
		
		console.log('Extracted branches from payments:', Array.from(branchSet));
		console.log('Extracted payment methods from payments:', Array.from(paymentMethodSet));
	}

	// Load scheduled payments from database
	async function loadScheduledPayments() {
		try {
			const { data, error } = await supabase
				.from('vendor_payment_schedule')
				.select(`
					*,
					receiving_records!receiving_record_id (
						accountant_user_id,
						bill_number,
						vendor_id,
						user_id,
						original_bill_url,
						users!user_id (
							username
						)
					)
				`)
				.order('due_date', { ascending: true });

			if (error) {
				console.error('Error loading scheduled payments:', error);
				return;
			}

			scheduledPayments = data || [];
		} catch (error) {
			console.error('Error loading scheduled payments:', error);
		}
	}

	// Auto-process Cash on Delivery payments
	// REMOVED: Database trigger now handles everything automatically on INSERT
	// This function is kept for backward compatibility but does nothing
	// Migration 70 trigger auto-marks COD as paid during INSERT
	async function processCashOnDeliveryPayments() {
		// No longer needed - database trigger handles COD auto-payment on INSERT
		// See migration 70_fix_cash_on_delivery_auto_payment.sql
		console.log('✅ Cash-on-delivery auto-payment now handled by database trigger (Migration 70)');
	}

	// Generate all days of the month (including days without payments)
	function generateAllDaysOfMonth(monthData) {
		const daysInMonth = new Date(monthData.year, monthData.month + 1, 0).getDate();
		monthDetailData = [];

		// Get today's date for comparison
		const today = new Date();
		const todayDate = today.getDate();
		const todayMonth = today.getMonth();
		const todayYear = today.getFullYear();

		// Create data for each day of the month
		for (let day = 1; day <= daysInMonth; day++) {
			const dayDate = new Date(monthData.year, monthData.month, day);
			const isToday = day === todayDate && monthData.month === todayMonth && monthData.year === todayYear;
			
			const dayInfo = {
				date: day,
				dayName: dayDate.toLocaleDateString('en-US', { weekday: 'short' }),
				fullDate: dayDate,
				dateString: dayDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' }),
				isToday: isToday,
				payments: [],
				paymentsByVendor: {},
				totalAmount: 0,
				unpaidAmount: 0,
				paymentCount: 0,
				isFullyPaid: true
			};

			// Find payments for this specific day (use filteredPayments)
			const paymentsToUse = filteredPayments || scheduledPayments;
			paymentsToUse.forEach(payment => {
				const paymentDate = new Date(payment.due_date);
				if (paymentDate.toDateString() === dayDate.toDateString()) {
					dayInfo.payments.push(payment);
					dayInfo.totalAmount += (payment.final_bill_amount || 0);
					dayInfo.paymentCount++;

					// Calculate unpaid amount
					if (!payment.is_paid) {
						dayInfo.unpaidAmount += (payment.final_bill_amount || 0);
						dayInfo.isFullyPaid = false;
					}

					// Group by vendor
					const vendorKey = payment.vendor_id || 'unknown';
					if (!dayInfo.paymentsByVendor[vendorKey]) {
						dayInfo.paymentsByVendor[vendorKey] = {
							vendor_name: payment.vendor_name || 'Unknown Vendor',
							vendor_id: payment.vendor_id,
							payments: [],
							totalAmount: 0
						};
					}
					dayInfo.paymentsByVendor[vendorKey].payments.push(payment);
					dayInfo.paymentsByVendor[vendorKey].totalAmount += (payment.final_bill_amount || 0);
				}
			});

			// Add ALL days (including empty ones)
			monthDetailData.push(dayInfo);
		}

		// Sort by date
		monthDetailData.sort((a, b) => a.date - b.date);
	}

	// Format currency display
	function formatCurrency(amount) {
		if (!amount || amount === 0) return '0.00';
		
		// Convert to number and format with exact precision (no rounding)
		const numericAmount = typeof amount === 'string' ? parseFloat(amount) : Number(amount);
		
		// Format with exactly 2 decimal places without rounding for display
		const formattedAmount = numericAmount.toFixed(2);
		
		// Add thousand separators while preserving exact decimals
		const [integer, decimal] = formattedAmount.split('.');
		const integerWithCommas = integer.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
		
		return `${integerWithCommas}.${decimal}`;
	}

	// Handle date selection and scroll to that date (legacy function for dropdown if needed)
	function handleDateSelect(event) {
		const selectedDate = event.target.value;
		
		if (selectedDate) {
			scrollToDate(selectedDate);
			// Reset the select after scrolling
			setTimeout(() => {
				event.target.value = '';
			}, 1000);
		}
	}

	// Scroll to specific date (used by calendar view)
	function scrollToDate(dateNumber) {
		// Use requestAnimationFrame to ensure DOM is ready
		requestAnimationFrame(() => {
			const element = document.getElementById(`day-${dateNumber}`);
			
			if (element) {
				// Simple scroll into view
				element.scrollIntoView({ 
					behavior: 'smooth', 
					block: 'center'
				});
			}
		});
	}

	// Format date for database without timezone conversion issues
	function formatDateForDB(date) {
		return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
	}

	// Function removed - now using is_paid boolean directly for styling

	// Get unique color for each vendor
	function getVendorColor(index) {
		const colors = [
			'#f97316', // Orange
			'#3b82f6', // Blue
			'#10b981', // Emerald
			'#8b5cf6', // Violet
			'#f59e0b', // Amber
			'#ef4444', // Red
			'#06b6d4', // Cyan
			'#84cc16', // Lime
			'#ec4899', // Pink
			'#6366f1'  // Indigo
		];
		return colors[index % colors.length];
	}

	// Drag and drop functions
	function handleDragStart(event, payment) {
		draggedPayment = payment;
		event.dataTransfer.setData('text/plain', payment.id);
		event.dataTransfer.effectAllowed = 'move';
	}

	function handleDragOver(event) {
		event.preventDefault();
		event.dataTransfer.dropEffect = 'move';
	}

	function handleDrop(event, targetDate) {
		event.preventDefault();
		
		if (!draggedPayment) return;

		const targetDateString = targetDate.toDateString();
		const originalDateString = new Date(draggedPayment.due_date).toDateString();

		// Don't do anything if dropped on the same date
		if (targetDateString === originalDateString) {
			draggedPayment = null;
			return;
		}

		// Show modal to choose between full move or split
		showRescheduleModal(draggedPayment, targetDate);
	}

	function showRescheduleModal(payment, newDate) {
		splitPayment = { ...payment, newDate };
		splitAmount = parseFloat(payment.final_bill_amount || payment.bill_amount || 0);
		remainingAmount = splitAmount;
		showSplitModal = true;
	}

	// Function to open reschedule modal from button click
	function openRescheduleModal(payment) {
		// For button click, we need to ask user for the new date
		// We'll modify the modal to include date picker when newDate is not provided
		splitPayment = { ...payment };
		splitAmount = parseFloat(payment.final_bill_amount || payment.bill_amount || 0);
		remainingAmount = splitAmount;
		showSplitModal = true;
	}

	function handleFullMove() {
		if (!splitPayment || !splitPayment.newDate) return;
		
		// Update the payment's due date
		updatePaymentDate(splitPayment.id, splitPayment.newDate, splitPayment.final_bill_amount);
		closeSplitModal();
	}

	async function handleSplitMove() {
		if (!splitPayment || !splitPayment.newDate || splitAmount <= 0 || splitAmount >= parseFloat(splitPayment.final_bill_amount)) {
			alert('Please enter a valid split amount and new date');
			return;
		}

		const originalAmount = parseFloat(splitPayment.final_bill_amount || splitPayment.bill_amount || 0);
		remainingAmount = originalAmount - splitAmount;

		try {
			// Create new payment record for the split amount
			await createSplitPayment(splitPayment, splitPayment.newDate, splitAmount);
			
			// Update original payment with remaining amount
			await updatePaymentAmount(splitPayment.id, remainingAmount);
			
			// Reload data to show updated amounts immediately
			await loadScheduledPayments();
			
		// Show success message
		alert(`Payment split successfully!\n\n✅ Created new payment: ${formatCurrency(splitAmount)} on ${formatDate(splitPayment.newDate)}\n✅ Updated original payment: ${formatCurrency(remainingAmount)} on ${formatDate(splitPayment.due_date)}`);			closeSplitModal();
		} catch (error) {
			console.error('Error splitting payment:', error);
			alert('Failed to split payment. Please try again.');
		}
	}

	function closeSplitModal() {
		showSplitModal = false;
		splitPayment = null;
		draggedPayment = null;
		splitAmount = 0;
		remainingAmount = 0;
		newDateInput = '';
	}

	async function updatePaymentDate(paymentId, newDate, amount) {
		try {
			const { error } = await supabase
				.from('vendor_payment_schedule')
				.update({ 
					due_date: formatDateForDB(newDate),
					updated_at: new Date().toISOString()
				})
				.eq('id', paymentId);

			if (error) {
				console.error('Error updating payment date:', error);
				alert('Failed to reschedule payment');
				return;
			}

			// Reload data
			await loadScheduledPayments();
			alert('Payment rescheduled successfully');
		} catch (error) {
			console.error('Error updating payment:', error);
			alert('Failed to reschedule payment');
		}
	}

	async function updatePaymentAmount(paymentId, newAmount) {
		try {
			const { error } = await supabase
				.from('vendor_payment_schedule')
				.update({ 
					final_bill_amount: newAmount,
					updated_at: new Date().toISOString()
				})
				.eq('id', paymentId);

			if (error) {
				console.error('Error updating payment amount:', error);
				return;
			}
		} catch (error) {
			console.error('Error updating payment amount:', error);
		}
	}

	async function createSplitPayment(originalPayment, newDate, amount) {
		try {
			const { error } = await supabase
				.from('vendor_payment_schedule')
				.insert({
					receiving_record_id: originalPayment.receiving_record_id,
					bill_number: originalPayment.bill_number + '-SPLIT',
					vendor_id: originalPayment.vendor_id,
					vendor_name: originalPayment.vendor_name,
					branch_id: originalPayment.branch_id,
					branch_name: originalPayment.branch_name,
					bill_date: originalPayment.bill_date,
					bill_amount: amount,
					final_bill_amount: amount,
					payment_method: originalPayment.payment_method,
					bank_name: originalPayment.bank_name,
					iban: originalPayment.iban,
					due_date: formatDateForDB(newDate),
				original_due_date: originalPayment.original_due_date, // Preserve original due date
				original_bill_amount: originalPayment.original_bill_amount, // Preserve original bill amount
				original_final_amount: originalPayment.original_final_amount, // Preserve original final amount
				credit_period: originalPayment.credit_period,
				vat_number: originalPayment.vat_number,
				is_paid: false,
				notes: (originalPayment.notes || '') + ' [Split from original payment]'
			});			if (error) {
				console.error('Error creating split payment:', error);
				alert('Failed to create split payment');
				return;
			}

			// Reload data
			await loadScheduledPayments();
			alert('Payment split and rescheduled successfully');
		} catch (error) {
			console.error('Error creating split payment:', error);
			alert('Failed to create split payment');
		}
	}

	// Handle payment status change (mark as paid)
	async function handlePaymentStatusChange(paymentId, isPaid, isAutoProcessed = false) {
		try {
			if (isPaid) {
				// First, get the payment details with receiving record information
				const { data: paymentData, error: paymentError } = await supabase
					.from('vendor_payment_schedule')
					.select(`
						*,
						receiving_records!receiving_record_id (
							accountant_user_id,
							bill_number,
							vendor_id,
							user_id,
							original_bill_url,
							users!user_id (
								username
							)
						)
					`)
					.eq('id', paymentId)
					.single();

				if (paymentError || !paymentData) {
					console.error('Error fetching payment data:', paymentError);
					alert('Failed to fetch payment details');
					return;
				}

			const payment = paymentData;
			const receivingRecord = payment.receiving_records;

			// Update payment status in vendor_payment_schedule
			const { error: updateError } = await supabase
				.from('vendor_payment_schedule')
				.update({ 
					is_paid: true, 
					paid_date: new Date().toISOString(),
					payment_reference: null,
					transaction_date: new Date().toISOString(),
					receiver_user_id: receivingRecord?.user_id,
					accountant_user_id: receivingRecord?.accountant_user_id,
					original_bill_url: receivingRecord?.original_bill_url,
					created_by: $currentUser?.id
				})
				.eq('id', paymentId);

			if (updateError) {
				console.error('Error updating payment status:', updateError);
				if (!isAutoProcessed) {
					alert('Failed to update payment status');
				}
				return;
			}				// Create task for accountant if we have accountant info
				if (receivingRecord?.accountant_user_id) {
					const receiverName = receivingRecord.users 
						? receivingRecord.users.username
						: 'Unknown';

					const taskTitle = 'New payment made — enter into the ERP, update the ERP reference, and upload the payment receipt';
					const taskDescription = `Payment Details:
- Bill Number: ${payment.bill_number || 'N/A'}
- Bill Amount: ${payment.bill_amount ? payment.bill_amount.toLocaleString() : 'N/A'}
- Vendor Name: ${payment.vendor_name || 'N/A'}
- Receiver: ${receiverName}
- Payment Method: ${payment.payment_method || 'N/A'}`;

					// Create the task
					const { data: taskData, error: taskError } = await supabase
						.from('tasks')
						.insert({
							title: taskTitle,
							description: taskDescription,
							created_by: $currentUser?.id,
							created_by_name: $currentUser?.username || $currentUser?.displayName,
							require_task_finished: true,
							priority: 'medium',
							status: 'active'
						})
						.select()
						.single();

					if (taskError) {
						console.error('Error creating task:', taskError);
					} else {
						// Assign task to accountant
						const { data: assignmentData, error: assignmentError } = await supabase
							.from('task_assignments')
							.insert({
								task_id: taskData.id,
								assignment_type: 'user',
								assigned_to_user_id: receivingRecord.accountant_user_id,
								assigned_by: $currentUser?.id,
								assigned_by_name: $currentUser?.username || $currentUser?.displayName,
								deadline_date: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString().split('T')[0], // Due tomorrow
								require_task_finished: true,
								status: 'assigned'
							})
							.select()
							.single();

						if (assignmentError) {
							console.error('Error assigning task:', assignmentError);
						} else {
							// Update vendor_payment_schedule with task and assignment IDs
							const { error: updatePaymentError } = await supabase
								.from('vendor_payment_schedule')
								.update({
									task_id: taskData.id,
									task_assignment_id: assignmentData.id
								})
								.eq('id', paymentId);

							if (updatePaymentError) {
								console.error('Error updating payment with task IDs:', updatePaymentError);
							}
							
							// Send notification to accountant
							try {
								const { error: notificationError } = await supabase
									.from('notifications')
									.insert({
										title: 'New Payment Task Assigned',
										message: `You have been assigned a payment processing task for ${payment.vendor_name || 'vendor'}. Bill Amount: ${payment.bill_amount ? payment.bill_amount.toLocaleString() : 'N/A'}`,
										type: 'task_assigned',
										priority: 'medium',
										target_type: 'specific_users',
										target_users: [receivingRecord.accountant_user_id],
										created_by: $currentUser?.id,
										created_by_name: $currentUser?.username || $currentUser?.displayName || 'System',
										task_id: taskData.id,
										task_assignment_id: assignmentData.id
									});

								if (notificationError) {
									console.error('Error sending notification:', notificationError);
								}
							} catch (notificationErr) {
								console.error('Error creating notification:', notificationErr);
							}
						}
					}
				}

				if (!isAutoProcessed) {
					alert('Payment marked as paid successfully and task created for accountant');
				}
		} else {
			// Unmark as paid - update vendor_payment_schedule
			const { error: updateError } = await supabase
				.from('vendor_payment_schedule')
				.update({ 
					is_paid: false, 
					payment_reference: null,
					paid_date: null,
					task_id: null,
					task_assignment_id: null,
					transaction_date: null
				})
				.eq('id', paymentId);

			if (updateError) {
				console.error('Error updating payment status:', updateError);
				alert('Failed to update payment status');
				return;
			}

			alert('Payment unmarked successfully');
		}			// Reload data to reflect changes
			await loadScheduledPayments();
		} catch (error) {
			console.error('Error handling payment status change:', error);
			alert('Failed to update payment status');
		}
	}

	// Edit payment method functions
	function openPaymentMethodEdit(payment) {
		editingPayment = payment;
		editingPaymentId = payment.id;
		editForm = {
			payment_method: payment.payment_method || 'Cash on Delivery',
			bank_name: payment.bank_name || '',
			iban: payment.iban || '',
			due_date: payment.due_date || '',
			credit_period: payment.credit_period || ''
		};
		showPaymentMethodModal = true;
	}

	function closePaymentMethodEdit() {
		showPaymentMethodModal = false;
		editingPayment = null;
		editingPaymentId = null;
		editForm = {
			payment_method: '',
			bank_name: '',
			iban: '',
			due_date: '',
			credit_period: ''
		};
	}

	// Edit form state
	let editForm = {
		payment_method: '',
		bank_name: '',
		iban: '',
		due_date: '',
		credit_period: ''
	};

	// Handle payment method changes to clear/show appropriate fields
	function handlePaymentMethodChange() {
		if (editForm.payment_method) {
			// Handle delivery methods
			if (editForm.payment_method === 'Cash on Delivery' || editForm.payment_method === 'Bank on Delivery') {
				editForm.credit_period = '';
				// Set due date to current date for both delivery methods
				const today = new Date();
				editForm.due_date = today.toISOString().split('T')[0];
				
				if (editForm.payment_method === 'Cash on Delivery') {
					editForm.bank_name = '';
					editForm.iban = '';
				}
			}
			// Clear bank fields for cash credit
			else if (editForm.payment_method === 'Cash Credit') {
				editForm.bank_name = '';
				editForm.iban = '';
			}
		}
	}

	// Calculate due date automatically when credit period changes for credit methods
	function handleCreditPeriodChange() {
		if (editForm.credit_period && (editForm.payment_method === 'Cash Credit' || editForm.payment_method === 'Bank Credit')) {
			const today = new Date();
			const creditDays = parseInt(editForm.credit_period);
			if (creditDays > 0) {
				const dueDate = new Date(today.getTime() + (creditDays * 24 * 60 * 60 * 1000));
				editForm.due_date = dueDate.toISOString().split('T')[0];
			}
		}
	}

	async function savePaymentMethodEdit() {
		if (!editingPaymentId || !editForm.payment_method) {
			alert('Please select a payment method');
			return;
		}

		try {
			const { error } = await supabase
				.from('vendor_payment_schedule')
				.update({ 
					payment_method: editForm.payment_method,
					bank_name: editForm.bank_name.trim() || null,
					iban: editForm.iban.trim() || null,
					due_date: editForm.due_date || null,
					credit_period: editForm.credit_period ? parseInt(editForm.credit_period) : null,
					updated_at: new Date().toISOString()
				})
				.eq('id', editingPaymentId);

			if (error) {
				console.error('Error updating payment method:', error);
				alert('Failed to update payment method');
				return;
			}

			// Reload data to reflect changes
			await loadScheduledPayments();
			alert('Payment method updated successfully');
			closePaymentMethodEdit();
		} catch (error) {
			console.error('Error updating payment method:', error);
			alert('Failed to update payment method');
		}
	}
</script>

<!-- Month Details Window Content -->
<div class="month-details-container">
	{#if monthData}
		<!-- Fixed Header Section -->
		<div class="fixed-header-section">
			<div class="header-cards-container">
			<!-- Compact Calendar Card with integrated summary -->
			<div class="header-card calendar-card">
				<div class="header-card-title">
					<h3>� Schedule Calendar</h3>
				</div>
				<div class="header-card-content">
					<!-- Payment Summary inside calendar -->
					<div class="calendar-summary">
						<div class="compact-stats">
							<div class="stat-item">
								<span class="stat-value">{monthDetailData.filter(d => d.paymentCount > 0).length}</span>
								<span class="stat-label">Days</span>
							</div>
							<div class="stat-item">
								<span class="stat-value">{monthData.paymentCount}</span>
								<span class="stat-label">Payments</span>
							</div>
							<div class="stat-item total-stat">
								<span class="stat-value total">{formatCurrency(monthData.total)}</span>
								<span class="stat-label">Total Scheduled Amount</span>
							</div>
							<div class="stat-item paid-stat">
								<span class="stat-value paid">{formatCurrency(totalPaidAmount)}</span>
								<span class="stat-label">Total Paid</span>
							</div>
							<div class="stat-item unpaid-stat">
								<span class="stat-value unpaid">{formatCurrency(totalUnpaidAmount)}</span>
								<span class="stat-label">Total Unpaid</span>
							</div>
						</div>
						
						<!-- Compact Payment Methods -->
						<div class="compact-methods">
							{#each Object.entries(totalsByPaymentMethod) as [method, amount]}
								<div class="method-chip">
									<span class="method-name">{method}</span>
									<span class="method-value">{formatCurrency(amount)}</span>
								</div>
							{/each}
						</div>
					</div>
					
					<div class="compact-calendar-grid">
						{#each monthDetailData as dayData}
							<div 
								class="mini-calendar-day {dayData.isToday ? 'is-today' : ''} {dayData.paymentCount > 0 ? (dayData.isFullyPaid ? 'has-payments fully-paid' : 'has-payments has-unpaid') : 'no-payments'}"
								on:click={() => scrollToDate(dayData.date)}
								title="Click to jump to {dayData.dayName}, {monthData.month} {dayData.date} - {dayData.paymentCount} payments, Total: {formatCurrency(dayData.totalAmount)}, Unpaid: {formatCurrency(dayData.unpaidAmount)}"
							>
								<div class="mini-day-info">
									<div class="mini-day-number">{dayData.date}</div>
									<div class="mini-day-name">{dayData.dayName}</div>
								</div>
								{#if dayData.paymentCount > 0}
									<div class="mini-payment-info">
										<div class="mini-count">{dayData.paymentCount} bills</div>
										<div class="mini-amount">{formatCurrency(dayData.totalAmount)}</div>
										{#if dayData.unpaidAmount > 0}
											<div class="mini-unpaid">Unpaid: {formatCurrency(dayData.unpaidAmount)}</div>
										{/if}
									</div>
								{/if}
							</div>
						{/each}
					</div>
				</div>
			</div>
		</div>
		</div>

		<!-- Scrollable Content Section -->
		<div class="scrollable-content-section">
			<!-- Days List -->
			<div class="month-days-list">
			{#each monthDetailData as dayData}
				<div 
					id="day-{dayData.date}"
					class="day-details-card" 
					class:has-payments={dayData.paymentCount > 0}
					class:drop-zone={draggedPayment}
					on:dragover={handleDragOver}
					on:drop={(e) => handleDrop(e, dayData.fullDate)}
				>
					<div class="day-details-header">
						<div class="day-info">
							<div class="day-date">{dayData.date}</div>
							<div class="day-name">{dayData.dayName}</div>
							<div class="day-full-date">{dayData.dateString}</div>
						</div>
						<div class="day-summary">
							{#if dayData.paymentCount > 0}
								<div class="day-count">{dayData.paymentCount} payment{dayData.paymentCount !== 1 ? 's' : ''}</div>
								<div class="day-amount">{formatCurrency(dayData.totalAmount)}</div>
							{:else}
								<div class="day-empty">No payments scheduled</div>
							{/if}
						</div>
					</div>

					<!-- Payment Sections (always show sections with headers) -->
					<div class="payment-sections">
						
						<!-- VENDOR PAYMENTS SECTION -->
						<div class="payment-section">
							<div class="section-header">
								<h3 class="section-title">🏪 Vendor Payments</h3>
								<div class="filter-controls">
									<select class="filter-select" bind:value={filterBranch}>
										<option value="">All Branches</option>
										{#each branches as branch}
											<option value={branch}>{branch}</option>
										{/each}
									</select>
									<select class="filter-select" bind:value={filterPaymentMethod}>
										<option value="">All Payment Methods</option>
										{#each paymentMethods as method}
											<option value={method}>{method}</option>
										{/each}
									</select>
								</div>
								<div class="section-summary">
									{#if dayData.paymentCount > 0}
										<span>{Object.keys(dayData.paymentsByVendor).length} vendor{Object.keys(dayData.paymentsByVendor).length !== 1 ? 's' : ''}</span>
										<span>{dayData.paymentCount} payment{dayData.paymentCount !== 1 ? 's' : ''}</span>
										<span>{formatCurrency(dayData.totalAmount)}</span>
									{:else}
										<span class="no-payments">No vendor payments scheduled</span>
									{/if}
								</div>
							</div>

								<!-- Common Table Header (separate from vendor cards) -->
								<div class="payments-table-wrapper">
								<div class="payments-table-header">
									<div class="table-header-row">
										<div class="header-column" title="Drag to reschedule">⋮⋮</div>
										<div class="header-column" title="Bill Number">Bill #</div>
										<div class="header-column" title="Vendor Name">Vendor</div>
										<div class="header-column" title="Final Bill Amount">Amount</div>
										<div class="header-column" title="Original Bill Amount">Orig. Bill</div>
										<div class="header-column" title="Original Final Amount">Orig. Final</div>
										<div class="header-column" title="Bill Date">Bill Date</div>
										<div class="header-column" title="Due Date">Due Date</div>
										<div class="header-column" title="Original Due Date">Orig. Due</div>
										<div class="header-column" title="Branch Name">Branch</div>
										<div class="header-column" title="Payment Method">Payment</div>
										<div class="header-column" title="Bank Name">Bank</div>
										<div class="header-column" title="IBAN">IBAN</div>
										<div class="header-column payment-status-header" title="Mark as Paid">Mark Paid</div>
										<div class="header-column status-header" title="Payment Status">Status</div>
										<div class="header-column actions-header" title="Reschedule Actions">Actions</div>
									</div>
								</div>

								<!-- Vendors Container with Payment Rows -->
								<div class="vendors-container">
									<div class="vendors-scroll-container">
									{#if dayData.paymentCount > 0}
										{#each Object.entries(dayData.paymentsByVendor) as [vendorKey, vendorGroup], vendorIndex}
											<!-- Payment Rows (matching table header) -->
											<div class="vendor-payments-rows">
												{#each vendorGroup.payments as payment}
													<div 
														class="payment-row"
														draggable="true"
														class:dragging={draggedPayment && draggedPayment.id === payment.id}
														on:dragstart={(e) => handleDragStart(e, payment)}
														title="Drag to reschedule payment - {vendorGroup.vendor_name}"
														style="border-left: 4px solid {getVendorColor(vendorIndex)};"
													>
														<div class="payment-data-row">
															<div class="data-cell drag-handle" style="color: {getVendorColor(vendorIndex)};">⋮⋮</div>
															<div class="data-cell bill-cell">
																<span class="bill-number-badge">#{payment.bill_number || 'N/A'}</span>
															</div>
															<div class="data-cell vendor-cell" style="color: {getVendorColor(vendorIndex)};">
																{vendorGroup.vendor_name}
															</div>
															<div class="data-cell amount">{formatCurrency(payment.final_bill_amount)}</div>
															<div class="data-cell amount original-amount">{formatCurrency(payment.original_bill_amount || 0)}</div>
															<div class="data-cell amount original-amount">{formatCurrency(payment.original_final_amount || 0)}</div>
															<div class="data-cell">{formatDate(payment.bill_date)}</div>
															<div class="data-cell">{formatDate(payment.due_date)}</div>
															<div class="data-cell">{formatDate(payment.original_due_date)}</div>
															<div class="data-cell">{payment.branch_name || 'N/A'}</div>
															<div class="data-cell payment-method-cell">
																<span class="payment-method">{payment.payment_method || 'Cash on Delivery'}</span>
																{#if !payment.is_paid}
																	<button 
																		class="edit-payment-method-btn"
																		on:click={() => openPaymentMethodEdit(payment)}
																		title="Edit payment method"
																	>
																		✏️
																	</button>
																{/if}
															</div>
															<div class="data-cell">{payment.bank_name || 'N/A'}</div>
															<div class="data-cell">{payment.iban || 'N/A'}</div>
															<div class="data-cell"></div>
															<div class="data-cell payment-status-cell">
																<input 
																	type="checkbox" 
																	class="payment-checkbox"
																	data-payment-id="{payment.id}"
																	checked={payment.is_paid || false}
																	on:change={(e) => handlePaymentStatusChange(payment.id, e.currentTarget.checked)}
																/>
															</div>
															<div class="data-cell status-cell">
																<span class="status-badge {payment.is_paid ? 'status-paid' : 'status-scheduled'}">
																	{payment.is_paid ? 'Paid' : 'Scheduled'}
																</span>
															</div>
															<div class="data-cell actions-cell">
																{#if !payment.is_paid}
																	<button 
																		class="reschedule-btn"
																		on:click|stopPropagation={() => openRescheduleModal(payment)}
																		title="Reschedule Payment"
																	>
																		📅
																	</button>
																{:else}
																	<span class="paid-label">✓</span>
																{/if}
															</div>
														</div>
													</div>
												{/each}
											</div>
						{/each}
									{:else}
										<!-- Empty state for vendor payments -->
										<div class="empty-payments-row">
											<div class="empty-message">No vendor payments scheduled for this date</div>
										</div>
									{/if}
									</div>
								</div>
								</div>
							</div>

							<!-- OTHER PAYMENTS SECTION (always visible) -->
							<div class="payment-section">
								<div class="section-header">
									<h3 class="section-title">💳 Other Payments</h3>
									<div class="section-summary">
										<span class="coming-soon">Coming Soon</span>
									</div>
								</div>
								
								<!-- Other Payments Table Header (always visible) -->
								<div class="payments-table-header">
									<div class="table-header-row">
										<div class="header-column">Description</div>
										<div class="header-column">Amount</div>
										<div class="header-column">Due Date</div>
										<div class="header-column">Category</div>
										<div class="header-column">Department</div>
										<div class="header-column">Payment Method</div>
										<div class="header-column">Account</div>
										<div class="header-column">Status</div>
									</div>
								</div>
								
								<div class="section-placeholder">
									<p>Other payment types will be implemented here</p>
									<small>(Employee payments, utilities, rent, etc.)</small>
								</div>
							</div>

						</div>
				</div>
			{/each}
			</div>
		</div>
	{:else}
		<div class="no-data">
			<p>No month data available</p>
		</div>
	{/if}
</div>

<!-- Split Payment Modal -->
{#if showSplitModal && splitPayment}
	<div class="modal-overlay" on:click={closeSplitModal}>
		<div class="modal-container" on:click|stopPropagation>
			<div class="modal-header">
				<h3>Reschedule Payment</h3>
				<button class="close-btn" on:click={closeSplitModal}>×</button>
			</div>
			
			<div class="modal-content">
				<div class="payment-info">
					<h4>Payment Split & Reschedule:</h4>
					<div class="payment-details-grid">
						<div class="detail-row">
							<span class="label">Vendor:</span>
							<span class="value">{splitPayment.vendor_name}</span>
						</div>
						<div class="detail-row">
							<span class="label">Bill Number:</span>
							<span class="value">{splitPayment.bill_number}</span>
						</div>
						<div class="detail-row">
							<span class="label">Current Amount:</span>
							<span class="value amount-current">{formatCurrency(splitPayment.final_bill_amount)}</span>
						</div>
						{#if splitPayment.original_final_amount || splitPayment.original_bill_amount}
						<div class="detail-row">
							<span class="label">Original Amount:</span>
							<span class="value amount-original">{formatCurrency(splitPayment.original_final_amount || splitPayment.original_bill_amount)}</span>
						</div>
						{/if}
						<div class="detail-row">
							<span class="label">Current Due Date:</span>
							<span class="value">{formatDate(splitPayment.due_date)}</span>
						</div>
						{#if splitPayment.original_due_date}
						<div class="detail-row">
							<span class="label">Original Due Date:</span>
							<span class="value">{formatDate(splitPayment.original_due_date)}</span>
						</div>
						{/if}
						<div class="detail-row">
							<span class="label">Split To Date:</span>
							<span class="value">{splitPayment.newDate ? formatDate(splitPayment.newDate) : 'Not set'}</span>
						</div>
						{#if !splitPayment.newDate}
						<div class="detail-row">
							<span class="label">Select New Date:</span>
							<input 
								type="date" 
								bind:value={newDateInput}
								on:change={(e) => {
									if (e.target.value) {
										splitPayment.newDate = new Date(e.target.value);
									}
								}}
								class="date-input"
								min={new Date().toISOString().split('T')[0]}
							/>
						</div>
						{/if}
					</div>
				</div>
				
				<div class="reschedule-options">
					<h4>Reschedule Options:</h4>
					
					<div class="option-group">
						<button class="option-btn full-move" on:click={handleFullMove}>
							<div class="option-icon">📦</div>
							<div class="option-text">
								<div class="option-title">Move Full Payment</div>
								<div class="option-desc">Move entire payment to new date</div>
							</div>
						</button>
					</div>
					
					<div class="option-group">
						<div class="split-option">
							<div class="split-header">
								<div class="option-icon">✂️</div>
								<div class="option-text">
									<div class="option-title">Split Payment</div>
									<div class="option-desc">Move partial amount to new date</div>
								</div>
							</div>
							
							<div class="split-inputs">
								<div class="input-group">
									<label>Amount to move to new date:</label>
									<input 
										type="number" 
										bind:value={splitAmount}
										max={parseFloat(splitPayment.final_bill_amount)}
										min="0.01"
										step="0.01"
										placeholder="Enter amount to split"
									/>
								</div>
								
								<!-- Amount Breakdown Display -->
								{#if splitAmount > 0 && splitAmount < parseFloat(splitPayment.final_bill_amount)}
									<div class="amount-breakdown">
										<div class="breakdown-header">
											<h5>Payment Split Breakdown:</h5>
										</div>
										<div class="breakdown-row">
											<span class="breakdown-label">Amount moving to {splitPayment.newDate ? formatDate(splitPayment.newDate) : 'Not set'}:</span>
											<span class="breakdown-value move-amount">+ {formatCurrency(splitAmount)}</span>
										</div>
										<div class="breakdown-row">
											<span class="breakdown-label">Amount remaining on {formatDate(splitPayment.due_date)}:</span>
											<span class="breakdown-value remain-amount">= {formatCurrency(parseFloat(splitPayment.final_bill_amount) - splitAmount)}</span>
										</div>
										<div class="breakdown-divider"></div>
										<div class="breakdown-row total">
											<span class="breakdown-label">Original Total:</span>
											<span class="breakdown-value">{formatCurrency(splitPayment.final_bill_amount)}</span>
										</div>
									</div>
								{/if}
								
								<div class="remaining-info">
									<p>Remaining: {formatCurrency(parseFloat(splitPayment.final_bill_amount) - splitAmount)}</p>
								</div>
								
								<button class="option-btn split-move" on:click={handleSplitMove}>
									Split & Move
								</button>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
{/if}

<!-- Edit Payment Method Modal -->
{#if showPaymentMethodModal && editingPayment}
	<div class="modal-overlay" on:click={closePaymentMethodEdit}>
		<div class="edit-modal" on:click|stopPropagation>
			<div class="modal-header">
				<h3>Edit Payment Details</h3>
				<button class="close-btn" on:click={closePaymentMethodEdit}>×</button>
			</div>
			
			<div class="modal-content">
				<div class="edit-form">
					<div class="form-row">
						<!-- Show Bank Name and IBAN only for Bank methods -->
						{#if editForm.payment_method && (editForm.payment_method === 'Bank on Delivery' || editForm.payment_method === 'Bank Credit')}
							<div class="form-group">
								<label for="bank_name">Bank Name</label>
								<input 
									type="text" 
									id="bank_name"
									bind:value={editForm.bank_name}
									placeholder="Enter bank name"
								/>
							</div>
							
							<div class="form-group">
								<label for="iban">IBAN</label>
								<input 
									type="text" 
									id="iban"
									bind:value={editForm.iban}
									placeholder="Enter IBAN number"
								/>
							</div>
						{:else}
							<!-- Empty placeholders when bank fields are not needed -->
							<div class="form-group placeholder-field">
								<label>Bank Name</label>
								<div class="disabled-field">Not applicable for {editForm.payment_method || 'selected payment method'}</div>
							</div>
							<div class="form-group placeholder-field">
								<label>IBAN</label>
								<div class="disabled-field">Not applicable for {editForm.payment_method || 'selected payment method'}</div>
							</div>
						{/if}
					</div>
					
					<div class="form-row">
						<div class="form-group">
							<label for="due_date">Due Date</label>
							<input 
								type="date" 
								id="due_date"
								bind:value={editForm.due_date}
								placeholder="dd/mm/yyyy"
							/>
						</div>
						
						<div class="form-group">
							<label for="payment_method">Payment Method</label>
							<select bind:value={editForm.payment_method} on:change={handlePaymentMethodChange}>
								<option value="">Select Payment Method</option>
								<option value="Cash on Delivery">Cash on Delivery</option>
								<option value="Bank on Delivery">Bank on Delivery</option>
								<option value="Cash Credit">Cash Credit</option>
								<option value="Bank Credit">Bank Credit</option>
							</select>
						</div>
					</div>
					
					<!-- Show Credit Period only for Credit methods -->
					{#if editForm.payment_method && (editForm.payment_method === 'Cash Credit' || editForm.payment_method === 'Bank Credit')}
						<div class="form-row single-column">
							<div class="form-group">
								<label for="credit_period">Credit Period (days)</label>
								<input 
									type="number" 
									id="credit_period"
									bind:value={editForm.credit_period}
									on:input={handleCreditPeriodChange}
									placeholder="Enter credit period in days"
									min="0"
								/>
							</div>
						</div>
					{:else if editForm.payment_method}
						<!-- Show disabled field for delivery methods -->
						<div class="form-row single-column">
							<div class="form-group placeholder-field">
								<label>Credit Period (days)</label>
								<div class="disabled-field">Not applicable for {editForm.payment_method}</div>
							</div>
						</div>
					{/if}
				</div>
			</div>
			
			<div class="modal-footer">
				<button class="cancel-btn" on:click={closePaymentMethodEdit}>Cancel</button>
				<button class="save-btn" on:click={savePaymentMethodEdit}>Save Changes</button>
			</div>
		</div>
	</div>
{/if}

<style>
	.month-details-container {
		display: flex;
		flex-direction: column;
		height: 100%;
		background: #f8fafc;
		overflow: hidden;
	}

	.fixed-header-section {
		flex-shrink: 0;
		padding: 8px 8px 0 8px;
		background: #f8fafc;
		border-bottom: 1px solid #e2e8f0;
	}

	.scrollable-content-section {
		flex: 1;
		overflow-y: auto;
		padding: 0 8px 8px 8px;
	}

	.month-details-header {
		margin-bottom: 24px;
		padding-bottom: 16px;
		border-bottom: 2px solid #e2e8f0;
		position: sticky;
		top: 0;
		background: white;
		z-index: 101;
		padding-top: 16px;
	}

	.month-details-header h2 {
		margin: 0;
		color: #1e293b;
		font-size: 24px;
		font-weight: 600;
	}

	.header-cards-container {
		display: block; /* Changed from grid to block for full width */
		margin-bottom: 12px;
	}

	.header-card {
		background: white;
		border-radius: 8px;
		box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
		overflow: hidden;
		transition: all 0.2s ease;
		border: 1px solid #e2e8f0;
		width: 100%; /* Full width */
	}

	.header-card:hover {
		box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
	}

	.header-card-title {
		background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
		padding: 12px 16px;
		border-bottom: 1px solid #e2e8f0;
	}

	.header-card-title h3 {
		margin: 0;
		font-size: 14px;
		font-weight: 600;
		color: #374151;
	}

	.payment-summary-card .header-card-title {
		background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
		border-bottom-color: #10b981;
	}

	.payment-summary-card .header-card-title h3 {
		color: #059669;
	}

	.calendar-card .header-card-title {
		background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
		border-bottom-color: #3b82f6;
	}

	.calendar-card .header-card-title h3 {
		color: #1d4ed8;
	}

	.header-card-content {
		padding: 16px;
	}

	.calendar-summary {
		margin-bottom: 12px;
		padding-bottom: 12px;
		border-bottom: 1px solid #e2e8f0;
	}

	.compact-stats {
		display: flex;
		gap: 12px;
		margin-bottom: 0;
		align-items: center;
	}

	.stat-item {
		display: flex;
		flex-direction: row;
		align-items: center;
		gap: 6px;
		padding: 4px 10px;
		background: #f8fafc;
		border-radius: 6px;
		min-width: auto;
		flex: 0 0 auto;
	}

	.stat-item.total-stat {
		background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
		border: 1px solid #10b981;
		margin-left: auto;
	}

	.stat-item.paid-stat {
		background: linear-gradient(135deg, #dbeafe 0%, #eff6ff 100%);
		border: 1px solid #3b82f6;
	}

	.stat-item.unpaid-stat {
		background: linear-gradient(135deg, #ffedd5 0%, #fff7ed 100%);
		border: 1px solid #fb923c;
	}

	.stat-value {
		font-weight: 700;
		color: #1e293b;
		font-size: 14px;
		line-height: 1;
	}

	.stat-value.total {
		color: #059669;
		font-size: 16px;
	}

	.stat-value.paid {
		color: #2563eb;
		font-size: 14px;
	}

	.stat-value.unpaid {
		color: #ea580c;
		font-size: 14px;
	}

	.stat-label {
		font-size: 11px;
		color: #64748b;
		font-weight: 500;
		text-align: center;
	}

	.compact-methods {
		display: none; /* Hide payment methods to save space */
	}

	.method-chip {
		display: flex;
		align-items: center;
		gap: 8px;
		padding: 6px 12px;
		background: #f1f5f9;
		border-radius: 20px;
		border: 1px solid #e2e8f0;
		font-size: 12px;
	}

	.method-name {
		color: #64748b;
		font-weight: 500;
	}

	.method-value {
		color: #059669;
		font-weight: 600;
	}

	.compact-calendar-grid {
		display: grid;
		grid-template-columns: repeat(7, 1fr);
		gap: 6px; /* Reduced from 8px */
		max-height: none; /* Remove max-height to show all dates without scrolling */
		overflow-y: visible; /* No scrolling needed */
		padding: 8px;
		background: #f8fafc;
		border-radius: 6px;
	}

	.mini-calendar-day {
		background: white;
		border: 1px solid #e5e7eb;
		border-radius: 8px;
		padding: 8px 6px; /* Reduced from 10px 6px */
		text-align: center;
		cursor: pointer;
		transition: all 0.2s ease;
		min-height: 50px; /* Reduced from 75px */
		display: flex;
		flex-direction: row; /* Changed to row layout */
		align-items: center;
		justify-content: space-between; /* Space between date and amount */
		font-size: 12px;
		position: relative;
	}

	.mini-calendar-day:hover {
		transform: translateY(-1px);
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
	}

	/* Fully paid dates - green background */
	.mini-calendar-day.has-payments.fully-paid {
		border-color: #10b981;
		background: linear-gradient(135deg, #d1fae5 0%, #ecfdf5 100%);
	}

	.mini-calendar-day.has-payments.fully-paid:hover {
		border-color: #059669;
		background: linear-gradient(135deg, #a7f3d0 0%, #d1fae5 100%);
	}

	.mini-calendar-day.has-payments.fully-paid .mini-day-number {
		color: #059669;
	}

	/* Unpaid dates - light orange background */
	.mini-calendar-day.has-payments.has-unpaid {
		border-color: #fb923c;
		background: linear-gradient(135deg, #fed7aa 0%, #ffedd5 100%);
	}

	.mini-calendar-day.has-payments.has-unpaid:hover {
		border-color: #f97316;
		background: linear-gradient(135deg, #fdba74 0%, #fed7aa 100%);
	}

	.mini-calendar-day.has-payments.has-unpaid .mini-day-number {
		color: #ea580c;
	}

	.mini-calendar-day.no-payments {
		border-color: #e2e8f0;
		background: #f9fafb;
		opacity: 0.7;
	}

	/* Today's date - light blue background */
	.mini-calendar-day.is-today {
		border-color: #3b82f6;
		background: linear-gradient(135deg, #dbeafe 0%, #eff6ff 100%);
		border-width: 2px;
	}

	.mini-calendar-day.is-today:hover {
		border-color: #2563eb;
		background: linear-gradient(135deg, #bfdbfe 0%, #dbeafe 100%);
	}

	.mini-calendar-day.is-today .mini-day-number {
		color: #1d4ed8;
		font-weight: 800;
	}

	/* Today with payments - combine both styles */
	.mini-calendar-day.is-today.has-payments.fully-paid {
		border-color: #3b82f6;
		background: linear-gradient(135deg, #bfdbfe 0%, #d1fae5 100%);
	}

	.mini-calendar-day.is-today.has-payments.has-unpaid {
		border-color: #3b82f6;
		background: linear-gradient(135deg, #bfdbfe 0%, #fed7aa 100%);
	}

	.mini-day-info {
		display: flex;
		flex-direction: column;
		align-items: flex-start;
		gap: 2px;
		flex-shrink: 0;
	}

	.mini-day-number {
		font-size: 16px; /* Reduced from 18px */
		font-weight: 700; /* Increased from 600 */
		color: #1e293b;
		line-height: 1;
		flex-shrink: 0;
	}

	.mini-day-name {
		font-size: 8px;
		color: #64748b;
		font-weight: 500;
		line-height: 1;
		text-transform: uppercase;
		letter-spacing: 0.3px;
	}

	.mini-payment-info {
		display: flex;
		flex-direction: column;
		align-items: flex-end; /* Align to the right */
		margin-top: 0; /* Remove top margin */
		gap: 2px;
		flex: 1;
		min-width: 0;
	}

	.mini-count {
		font-size: 8px; /* Reduced from 10px */
		color: #059669;
		font-weight: 600;
		line-height: 1;
		white-space: nowrap;
	}

	.mini-amount {
		font-size: 10px; /* Reduced from 11px */
		color: #1e293b;
		font-weight: 700;
		line-height: 1;
		background: rgba(16, 185, 129, 0.15);
		padding: 2px 4px; /* Reduced from 3px 5px */
		border-radius: 3px;
		white-space: nowrap;
	}

	/* Unpaid amount styling */
	.mini-unpaid {
		font-size: 8px; /* Reduced from 10px */
		color: #ea580c;
		font-weight: 700;
		line-height: 1;
		background: rgba(249, 115, 22, 0.15);
		padding: 2px 4px; /* Reduced from 3px 5px */
		border-radius: 3px;
		margin-top: 1px;
		white-space: nowrap;
	}

	/* Update color for unpaid dates */
	.mini-calendar-day.has-unpaid .mini-count {
		color: #ea580c;
	}

	.day-number {
		font-size: 18px;
		font-weight: 700;
		color: #1e293b;
		margin-bottom: 4px;
		line-height: 1;
	}

	.calendar-day.has-payments .day-number {
		color: #059669;
	}

	.day-name {
		font-size: 11px;
		color: #64748b;
		font-weight: 500;
		margin-bottom: 6px;
		text-transform: uppercase;
		letter-spacing: 0.5px;
	}

	.payment-info {
		flex: 1;
		display: flex;
		flex-direction: column;
		justify-content: center;
		background: rgba(16, 185, 129, 0.1);
		border-radius: 6px;
		padding: 6px 4px;
		margin-top: 4px;
	}

	.payment-count {
		font-size: 10px;
		color: #059669;
		font-weight: 600;
		margin-bottom: 2px;
	}

	.payment-total {
		font-size: 10px;
		color: #1e293b;
		font-weight: 700;
	}

	.no-payment-info {
		flex: 1;
		display: flex;
		align-items: center;
		justify-content: center;
		font-size: 9px;
		color: #9ca3af;
		font-weight: 500;
	}

	.summary-label {
		font-size: 12px;
		color: #64748b;
		font-weight: 500;
	}

	.summary-value {
		font-size: 18px;
		font-weight: 700;
		color: #059669;
	}

	.month-days-list {
		display: flex;
		flex-direction: column;
		gap: 16px;
	}

	.day-details-card {
		background: white;
		border: 1px solid #e2e8f0;
		border-radius: 8px;
		padding: 20px;
		transition: all 0.2s;
	}

	.day-details-card.has-payments {
		border-left: 4px solid #f97316;
		border: 2px solid #fed7aa;
		box-shadow: 0 2px 8px rgba(249, 115, 22, 0.1);
	}

	.day-details-card:not(.has-payments) {
		background: #f9fafb;
		border-style: dashed;
		opacity: 0.7;
	}

	.day-details-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 16px;
	}

	.day-info .day-date {
		font-size: 24px;
		font-weight: 700;
		color: #1e293b;
		margin-bottom: 2px;
	}

	.day-info .day-name {
		font-size: 14px;
		color: #475569;
		font-weight: 600;
		margin-bottom: 2px;
	}

	.day-info .day-full-date {
		font-size: 12px;
		color: #64748b;
	}

	.day-summary {
		text-align: right;
	}

	.day-count {
		font-size: 12px;
		color: #64748b;
		margin-bottom: 4px;
	}

	.day-amount {
		font-size: 18px;
		font-weight: 700;
		color: #059669;
	}

	.day-empty {
		font-size: 14px;
		color: #94a3b8;
		font-style: italic;
	}

	/* Payment Sections */
	.payment-sections {
		padding: 20px;
		display: flex;
		flex-direction: column;
		gap: 32px;
	}

	.payment-section {
		border: 2px solid #e5e7eb;
		border-radius: 12px;
		overflow: hidden;
		background: white;
		box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
	}

	.section-header {
		padding: 16px 20px;
		background: #f8fafc;
		border-bottom: 2px solid #e5e7eb;
		display: flex;
		justify-content: space-between;
		align-items: center;
		gap: 16px;
		flex-wrap: wrap;
	}

	.filter-controls {
		display: flex;
		gap: 12px;
		align-items: center;
	}

	.filter-select {
		padding: 8px 12px;
		border: 1px solid #e5e7eb;
		border-radius: 6px;
		background: white;
		font-size: 13px;
		color: #374151;
		cursor: pointer;
		transition: all 0.2s;
		min-width: 180px;
	}

	.filter-select:hover {
		border-color: #3b82f6;
	}

	.filter-select:focus {
		outline: none;
		border-color: #3b82f6;
		box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
	}

	.section-title {
		font-size: 18px;
		font-weight: 700;
		margin: 0;
		color: #1e293b;
		display: flex;
		align-items: center;
		gap: 8px;
	}

	.section-summary {
		display: flex;
		gap: 16px;
		font-size: 14px;
		color: #64748b;
		font-weight: 500;
	}

	.section-placeholder {
		padding: 40px 20px;
		text-align: center;
		color: #9ca3af;
		font-style: italic;
	}

	.coming-soon {
		background: #fbbf24;
		color: #92400e;
		padding: 4px 8px;
		border-radius: 4px;
		font-size: 12px;
		font-weight: 600;
	}

	.no-payments {
		color: #9ca3af;
		font-style: italic;
		font-size: 14px;
	}

	.empty-payments-row {
		padding: 40px 20px;
		text-align: center;
		border: 1px solid #e5e7eb;
		border-top: none;
		background: #fafafa;
		border-radius: 0 0 8px 8px;
	}

	.empty-message {
		color: #9ca3af;
		font-style: italic;
		font-size: 16px;
		margin-bottom: 8px;
	}

	.section-placeholder {
		padding: 30px 20px;
		text-align: center;
		color: #9ca3af;
		font-style: italic;
		border: 1px solid #e5e7eb;
		border-top: none;
		background: #fafafa;
		border-radius: 0 0 8px 8px;
	}

	.section-placeholder small {
		display: block;
		margin-top: 8px;
		font-size: 12px;
		color: #6b7280;
	}

	.day-payments-table {
		overflow-x: auto;
	}

	.day-payments-table table {
		width: 100%;
		border-collapse: collapse;
		background: white;
		border-radius: 6px;
		overflow: hidden;
		box-shadow: 0 1px 4px rgba(0, 0, 0, 0.05);
	}

	.day-payments-table th {
		background: #fff7ed;
		color: #9a3412;
		font-weight: 600;
		font-size: 11px;
		text-transform: uppercase;
		letter-spacing: 0.5px;
		padding: 16px 12px;
		text-align: left;
		border-bottom: 2px solid #f97316;
		border-top: 2px solid #f97316;
		vertical-align: top;
	}

	.day-payments-table td {
		padding: 16px 12px;
		border-bottom: 1px solid #f1f5f9;
		font-size: 13px;
		color: #374151;
		vertical-align: top;
	}

	.day-payments-table tbody tr {
		border: 2px solid #f97316;
		border-radius: 8px;
		margin-bottom: 12px;
		background: #fffbf5;
		box-shadow: 0 2px 4px rgba(249, 115, 22, 0.1);
	}

	.day-payments-table tbody tr:hover {
		background: #fff7ed;
		border-color: #ea580c;
		box-shadow: 0 4px 12px rgba(249, 115, 22, 0.3);
		transform: translateY(-1px);
	}

	/* Bill Details Cell */
	.bill-details-cell .bill-number {
		font-weight: 700;
		color: #1e293b;
		font-size: 14px;
		margin-bottom: 4px;
	}

	.bill-details-cell .bill-date,
	.bill-details-cell .due-date {
		font-size: 11px;
		color: #64748b;
		margin-bottom: 2px;
	}

	/* Vendor Details Cell */
	.vendor-details-cell .vendor-name {
		font-weight: 600;
		color: #1e293b;
		font-size: 14px;
		margin-bottom: 4px;
	}

	.vendor-details-cell .vendor-id,
	.vendor-details-cell .vat-number {
		font-size: 11px;
		color: #64748b;
		margin-bottom: 2px;
		font-family: monospace;
	}

	/* Branch Cell */
	.branch-cell .branch-name {
		font-weight: 600;
		color: #1e293b;
		font-size: 13px;
		margin-bottom: 4px;
	}

	.branch-cell .branch-id {
		font-size: 11px;
		color: #64748b;
		font-family: monospace;
	}

	/* Payment Details Cell */
	.payment-details-cell .amount {
		font-weight: 700;
		color: #059669;
		font-size: 15px;
		margin-bottom: 4px;
	}

	.payment-details-cell .original-amount {
		font-size: 11px;
		color: #64748b;
		margin-bottom: 4px;
	}

	.payment-details-cell .payment-method {
		font-size: 12px;
		color: #374151;
		background: #e5e7eb;
		padding: 2px 6px;
		border-radius: 4px;
		display: inline-block;
		margin-bottom: 4px;
	}

	.payment-details-cell .credit-period {
		font-size: 11px;
		color: #64748b;
	}

	/* Banking Cell */
	.banking-cell .bank-name {
		font-weight: 600;
		color: #1e293b;
		font-size: 13px;
		margin-bottom: 4px;
	}

	.banking-cell .iban {
		font-size: 11px;
		color: #64748b;
		font-family: monospace;
		word-break: break-all;
	}

	/* Status Cell */
	.status-cell {
		text-align: center !important;
		margin-left: 70px !important;
		padding-left: 35px !important;
		display: flex !important;
		justify-content: flex-end !important;
		width: 100% !important;
		position: relative !important;
		right: -50px !important;
	}

	.header-column.status-header {
		margin-left: 0px;
		padding-left: 0px;
		text-align: center;
		margin-right: 0px;
		padding-right: 0px;
		width: 100%;
		display: flex;
		justify-content: center;
		overflow: visible;
	}

	.status-cell .scheduled-date,
	.status-cell .paid-date {
		font-size: 10px;
		color: #64748b;
		margin-top: 4px;
	}

	.status-cell .paid-date {
		color: #059669;
		font-weight: 600;
	}

	/* Vendor Grouping Styles */
	.vendors-scroll-container {
		min-width: 1527px;
	}

	.vendors-container {
		display: flex;
		flex-direction: column;
		gap: 0;
	}

	.vendor-group {
		border: 1px solid #e5e7eb;
		border-top: none;
		border-radius: 0;
		overflow: hidden;
		background: white;
		margin: 0;
		padding: 0;
	}

	.vendor-summary {
		display: flex;
		gap: 12px;
		font-size: 12px;
		font-weight: 600;
		color: #374151;
	}

	/* Table Wrapper */
	.payments-table-wrapper {
		overflow-x: auto;
		margin: 0 -20px;
		padding: 0 20px;
	}

	/* Table Header Structure */
	.payments-table-header {
		background: #f1f5f9;
		border: 2px solid #e2e8f0;
		border-radius: 8px 8px 0 0;
		margin-bottom: 0;
		min-width: 1527px;
	}

	.table-header-row {
		display: grid;
		grid-template-columns: 40px 140px 180px 100px 110px 110px 95px 95px 105px 130px 100px 150px 140px 100px 140px 120px;
		gap: 12px;
		padding: 14px 18px;
		margin-left: 0px;
		box-sizing: border-box;
		width: 100%;
		font-weight: 700;
		color: #475569;
		text-transform: uppercase;
		font-size: 10px;
		letter-spacing: 0.3px;
		white-space: nowrap;
		overflow: hidden;
	}

	.header-column {
		text-align: left;
		display: flex;
		align-items: center;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
		padding: 8px 4px;
	}

	.header-column:nth-child(4),
	.header-column:nth-child(5),
	.header-column:nth-child(6) {
		text-align: right;
		justify-content: flex-end;
	}

	.vendors-scroll-container {
		overflow-x: auto;
		min-width: 100%;
		width: 1200px;
	}

	/* Vendor Structure */
	.vendor-title-row {
		padding: 6px 16px;
		margin: 0;
		display: flex;
		justify-content: space-between;
		align-items: center;
		border-bottom: 1px solid #e5e7eb;
		border-top: none;
		min-width: 1100px;
		font-size: 12px;
	}

	.vendor-name {
		margin: 0;
		font-size: 14px;
		font-weight: 700;
	}

	.vendor-payments-rows {
		display: flex;
		flex-direction: column;
		margin: 0;
		padding: 0;
	}

	.vendor-payments-table table {
		width: 100%;
		border-collapse: separate;
		border-spacing: 0;
		margin: 0;
	}

	.vendor-payments-table thead {
		display: none;
	}

	.vendor-payments-table tbody tr {
		border: 2px solid;
		border-radius: 8px;
		margin: 12px;
		background: white;
		display: block;
		padding: 16px;
		box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
	}

	.vendor-payments-table tbody tr:hover {
		background: #f9fafb;
		transform: translateY(-2px);
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
	}

	/* Payment Row Styles */
	.payment-row {
		border: none;
		border-bottom: 1px solid #e5e7eb;
		margin: 0;
		background: white;
		padding: 0;
		cursor: grab;
		transition: all 0.2s ease;
		position: relative;
		display: flex;
		align-items: flex-start;
		gap: 0;
		min-width: 1527px;
		min-height: 50px;
	}

	.payment-row:last-child {
		border-radius: 0 0 8px 8px;
	}

	.payment-row:hover {
		background: #f9fafb;
		transform: translateX(2px);
	}

	.payment-row.dragging {
		opacity: 0.5;
		cursor: grabbing;
		background: #fef3c7;
	}

	.payment-data-row {
		display: grid;
		grid-template-columns: 40px 140px 180px 100px 110px 110px 95px 95px 105px 130px 100px 150px 140px 80px 5px 140px 120px;
		gap: 12px;
		flex: 1;
		align-items: center;
		grid-auto-rows: minmax(50px, auto);
		padding: 8px 18px;
		margin-left: 0px;
		width: 100%;
		box-sizing: border-box;
	}

	.data-cell {
		font-size: 11px;
		color: #374151;
		display: flex;
		align-items: center;
		justify-content: flex-start;
		padding: 8px 4px;
		word-wrap: break-word;
		word-break: break-word;
		hyphens: auto;
		line-height: 1.2;
		min-height: 40px;
		vertical-align: middle;
	}

	.data-cell:nth-child(13) {
		padding-left: 80px;
		min-width: 300px;
		max-width: 300px;
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}

	.data-cell:nth-child(12) {
		padding-left: 120px;
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
		min-width: 200px;
		max-width: 200px;
	}

	.data-cell:nth-child(11) {
		padding-left: 140px;
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
		min-width: 300px;
		max-width: 300px;
	}

	.data-cell:nth-child(10) {
		padding-left: 100px;
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
		min-width: 250px;
		max-width: 250px;
	}

	.data-cell:nth-child(9) {
		padding-left: 110px;
		white-space: nowrap;
	}

	.data-cell:nth-child(8) {
		padding-left: 110px;
		white-space: nowrap;
	}

	.data-cell:nth-child(7) {
		padding-left: 120px;
		white-space: nowrap;
	}

	.data-cell:nth-child(6) {
		padding-left: 200px;
	}

	.data-cell:nth-child(5) {
		padding-left: 200px;
	}

	.data-cell:nth-child(4) {
		padding-left: 280px;
	}

	.data-cell:nth-child(3) {
		padding-left: 100px;
	}

	.data-cell.amount {
		font-weight: 800; /* same as original amounts */
		color: #059669;
		font-size: 12px; /* same as original amounts */
		text-align: right;
		justify-content: flex-end;
		font-family: monospace;
		align-items: flex-start;
		white-space: nowrap;
		padding-right: 6px; /* small breathing room from edge */
	}

	.data-cell.amount.original-amount {
		font-weight: 800; /* even bolder for original amounts */
		font-size: 12px; /* bigger size */
		color: #0d7377; /* slightly different green */
	}

	.data-cell.drag-handle {
		font-size: 14px;
		cursor: grab;
		opacity: 0.5;
		transition: opacity 0.2s;
		display: flex;
		align-items: center;
		justify-content: center;
		font-weight: bold;
		min-height: 30px;
	}

	.payment-row:hover .data-cell.drag-handle {
		opacity: 1;
	}

	.bill-info {
		display: flex;
		flex-direction: column;
		gap: 2px;
	}

	.bill-number {
		font-weight: 600;
		font-size: 11px;
		color: #1e293b;
	}

	.vendor-name-small {
		font-size: 9px;
		font-weight: 500;
		opacity: 0.8;
	}

	.data-cell.vendor-cell {
		font-weight: 600;
		font-size: 10px;
		word-wrap: break-word;
		word-break: break-word;
		hyphens: auto;
		margin-left: 0px;
		padding-left: 65px;
		display: flex;
		align-items: center;
		justify-content: flex-start;
		min-height: 40px;
		white-space: normal;
		overflow: visible;
		min-width: 280px;
		max-width: 280px;
	}

	.data-cell.bill-cell {
		display: flex;
		align-items: center;
		justify-content: flex-start;
		overflow: hidden;
		max-width: 110px;
		min-width: 110px;
		width: 110px;
		padding-left: 0px;
		margin-left: 0px;
		min-height: 40px;
	}

	.bill-number-badge {
		background: #f3f4f6;
		padding: 4px 6px;
		border-radius: 4px;
		font-size: 10px;
		font-weight: 600;
		color: #374151;
		border: 1px solid #e5e7eb;
		display: inline-block;
		white-space: normal;
		max-width: 120px;
		width: fit-content;
		text-align: center;
		word-break: break-word;
		line-height: 1.3;
	}

	.payment-method {
		background: #e5e7eb;
		padding: 1px 4px;
		border-radius: 3px;
		font-size: 9px;
		font-weight: 600;
		display: inline-block;
		width: fit-content;
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
		max-width: 100%;
	}

	/* Drag and Drop Styles */
	.payment-row {
		cursor: grab;
		transition: all 0.2s ease;
		position: relative;
	}

	.payment-row:hover {
		background: #f8fafc;
		box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
	}

	.payment-row.dragging {
		opacity: 0.5;
		cursor: grabbing;
		background: #e2e8f0;
	}

	.drag-handle {
		position: absolute;
		left: -20px;
		top: 50%;
		transform: translateY(-50%);
		color: #f97316;
		font-size: 12px;
		cursor: grab;
		writing-mode: vertical-lr;
		line-height: 1;
		font-weight: bold;
	}

	.day-details-card.drop-zone {
		border: 2px dashed #3b82f6;
		background: #eff6ff;
		transition: all 0.2s ease;
	}

	.day-details-card.drop-zone:hover {
		border-color: #1d4ed8;
		background: #dbeafe;
	}

	/* Modal Styles */
	.modal-overlay {
		position: fixed;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		background: rgba(0, 0, 0, 0.5);
		display: flex;
		justify-content: center;
		align-items: center;
		z-index: 10000;
	}

	.modal-container {
		background: white;
		border-radius: 12px;
		padding: 0;
		min-width: 500px;
		max-width: 600px;
		max-height: 80vh;
		overflow-y: auto;
		box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
	}

	.modal-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 20px 24px 16px;
		border-bottom: 1px solid #e2e8f0;
	}

	.modal-header h3 {
		margin: 0;
		color: #1e293b;
		font-size: 20px;
		font-weight: 600;
	}

	.modal-header .close-btn {
		background: none;
		border: none;
		font-size: 24px;
		color: #64748b;
		cursor: pointer;
		padding: 0;
		width: 30px;
		height: 30px;
		display: flex;
		align-items: center;
		justify-content: center;
		border-radius: 50%;
		transition: all 0.2s;
	}

	.modal-header .close-btn:hover {
		background: #f1f5f9;
		color: #1e293b;
	}

	.modal-content {
		padding: 24px;
	}

	.payment-info {
		background: #f8fafc;
		padding: 16px;
		border-radius: 8px;
		margin-bottom: 24px;
	}

	.payment-info h4 {
		margin: 0 0 12px 0;
		color: #1e293b;
		font-size: 16px;
	}

	.payment-info p {
		margin: 4px 0;
		font-size: 14px;
		color: #475569;
	}

	.reschedule-options h4 {
		margin: 0 0 16px 0;
		color: #1e293b;
		font-size: 16px;
	}

	.option-group {
		margin-bottom: 16px;
	}

	.option-btn {
		display: flex;
		align-items: center;
		width: 100%;
		padding: 16px;
		border: 2px solid #e2e8f0;
		border-radius: 8px;
		background: white;
		cursor: pointer;
		transition: all 0.2s;
		text-align: left;
	}

	.option-btn:hover {
		border-color: #3b82f6;
		background: #f8fafc;
	}

	.option-btn.full-move:hover {
		border-color: #059669;
		background: #f0fdf4;
	}

	.option-btn.split-move {
		background: #3b82f6;
		color: white;
		border-color: #3b82f6;
		margin-top: 12px;
	}

	.option-btn.split-move:hover {
		background: #2563eb;
	}

	.option-icon {
		font-size: 24px;
		margin-right: 12px;
	}

	.option-title {
		font-weight: 600;
		color: #1e293b;
		margin-bottom: 2px;
	}

	.option-desc {
		font-size: 12px;
		color: #64748b;
	}

	.split-option {
		border: 2px solid #e2e8f0;
		border-radius: 8px;
		padding: 16px;
	}

	.split-header {
		display: flex;
		align-items: center;
		margin-bottom: 16px;
	}

	.split-inputs {
		padding-left: 36px;
	}

	.input-group {
		margin-bottom: 12px;
	}

	.input-group label {
		display: block;
		margin-bottom: 4px;
		font-size: 14px;
		color: #374151;
		font-weight: 500;
	}

	.input-group {
		position: relative;
	}

	.input-group input {
		width: 100%;
		padding: 8px 12px;
		padding-right: 50px;
		border: 1px solid #d1d5db;
		border-radius: 6px;
		font-size: 14px;
	}

	.currency-symbol {
		position: absolute;
		right: 12px;
		top: 50%;
		transform: translateY(-50%);
		color: #6b7280;
		font-weight: 600;
		font-size: 14px;
	}

	/* Payment Details Grid */
	.payment-details-grid {
		display: flex;
		flex-direction: column;
		gap: 8px;
		margin-top: 12px;
	}

	.detail-row {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 6px 0;
		border-bottom: 1px solid #f3f4f6;
	}

	.detail-row .label {
		font-weight: 600;
		color: #374151;
		font-size: 14px;
	}

	.detail-row .value {
		color: #1f2937;
		font-size: 14px;
	}

	.detail-row .amount-original {
		font-weight: 700;
		color: #3b82f6;
		font-size: 16px;
	}

	/* Amount Breakdown */
	.amount-breakdown {
		margin-top: 16px;
		padding: 16px;
		background: #f8fafc;
		border: 1px solid #e2e8f0;
		border-radius: 8px;
	}

	.breakdown-header h5 {
		margin: 0 0 12px 0;
		font-size: 16px;
		font-weight: 700;
		color: #1e293b;
	}

	.breakdown-row {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 8px 0;
		font-size: 14px;
	}

	.breakdown-label {
		color: #475569;
		font-weight: 500;
	}

	.breakdown-value {
		font-weight: 700;
		color: #1f2937;
	}

	.breakdown-value.move-amount {
		color: #059669;
	}

	.breakdown-value.remain-amount {
		color: #dc2626;
	}

	.breakdown-row.total {
		border-top: 2px solid #e2e8f0;
		margin-top: 8px;
		padding-top: 12px;
		font-weight: 700;
	}

	.breakdown-divider {
		height: 1px;
		background: #e2e8f0;
		margin: 8px 0;
	}

	.input-group input:focus {
		outline: none;
		border-color: #3b82f6;
		box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
	}

	.remaining-info {
		margin-bottom: 16px;
		padding: 8px 12px;
		background: #f0fdf4;
		border-radius: 6px;
		border-left: 3px solid #059669;
	}

	.remaining-info p {
		margin: 0;
		font-size: 14px;
		color: #059669;
		font-weight: 600;
	}

	.status-badge {
		padding: 4px 8px;
		border-radius: 4px;
		font-size: 11px;
		font-weight: 600;
		text-transform: uppercase;
		margin-left: 0px;
		white-space: nowrap;
		display: inline-block;
		min-width: 80px;
		text-align: center;
	}

	.status-scheduled {
		background: #dbeafe;
		color: #1e40af;
	}

	.status-paid {
		background: #dcfce7;
		color: #166534;
	}

	.status-cancelled {
		background: #fef2f2;
		color: #991b1b;
	}

	.status-overdue {
		background: #fee2e2;
		color: #991b1b;
	}

	.no-data {
		display: flex;
		justify-content: center;
		align-items: center;
		height: 200px;
		color: #64748b;
		font-style: italic;
	}

	/* Responsive Design */
	@media (max-width: 1024px) {
		.header-cards-container {
			grid-template-columns: 1fr;
			gap: 12px;
		}
		
		.compact-calendar-grid {
			max-height: 140px;
		}
		
		.compact-stats {
			gap: 12px;
		}
	}

	@media (max-width: 768px) {
		.header-card-content {
			padding: 12px;
		}
		
		.header-card-title {
			padding: 10px 12px;
		}
		
		.header-card-title h3 {
			font-size: 13px;
		}
		
		.compact-calendar-grid {
			gap: 3px;
			max-height: 120px;
		}
		
		.mini-calendar-day {
			min-height: 28px;
			padding: 4px 2px;
		}
		
		.mini-day-number {
			font-size: 11px;
		}
		
		.mini-payment-indicator {
			width: 12px;
			height: 12px;
			font-size: 7px;
		}
		
		.compact-stats {
			gap: 8px;
		}
		
		.stat-item {
			padding: 6px 8px;
			min-width: 50px;
		}
		
		.stat-value {
			font-size: 14px;
		}
		
		.stat-value.total {
			font-size: 16px;
		}
		
		.method-chip {
			padding: 4px 8px;
			font-size: 11px;
		}
	}

	@media (max-width: 480px) {
		.header-cards-container {
			gap: 8px;
		}
		
		.compact-calendar-grid {
			gap: 2px;
			max-height: 100px;
			padding: 2px;
		}
		
		.mini-calendar-day {
			min-height: 24px;
			padding: 2px 1px;
		}
		
		.mini-day-number {
			font-size: 10px;
		}
		
		.mini-payment-indicator {
			width: 10px;
			height: 10px;
			font-size: 6px;
		}
		
		.compact-stats {
			flex-direction: column;
			gap: 6px;
		}
		
		.stat-item {
			flex-direction: row;
			justify-content: space-between;
			padding: 6px 10px;
		}
		
		.compact-methods {
			gap: 4px;
		}
		
		.method-chip {
			padding: 3px 6px;
			font-size: 10px;
		}
	}





	.payment-status-header {
		text-align: center;
		font-size: 10px;
		font-weight: 700;
		color: #475569;
		text-transform: uppercase;
	}

	.payment-status-cell {
		display: flex;
		align-items: center;
		justify-content: center;
		padding: 8px;
	}

	.payment-checkbox {
		width: 20px;
		height: 20px;
		cursor: pointer;
		accent-color: #10b981;
		margin: 2;
		opacity: 1 !important;
		position: relative !important;
		z-index: 10;
	}

	/* Payment Method Edit Button Styles */
	.payment-method-cell {
		display: flex;
		align-items: center;
		gap: 8px;
		justify-content: flex-start;
		position: relative;
	}

	.edit-payment-method-btn {
		background: #f59e0b;
		color: white;
		border: none;
		border-radius: 4px;
		padding: 4px 6px;
		font-size: 12px;
		cursor: pointer;
		transition: all 0.2s ease;
		opacity: 0.8;
		min-width: 24px;
		height: 24px;
		display: flex;
		align-items: center;
		justify-content: center;
		margin-left: 8px;
		flex-shrink: 0;
	}

	.edit-payment-method-btn:hover {
		background: #d97706;
		opacity: 1;
		transform: scale(1.1);
	}

	/* Edit Modal Styles - Matching PaymentManager */
	.edit-modal {
		background: white;
		border-radius: 12px;
		width: 90%;
		max-width: 600px;
		max-height: 80vh;
		overflow-y: auto;
		box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
	}

	.edit-form {
		display: flex;
		flex-direction: column;
		gap: 20px;
	}

	.form-row {
		display: grid;
		grid-template-columns: 1fr 1fr;
		gap: 16px;
	}

	.form-row.single-column {
		grid-template-columns: 1fr;
	}

	.form-group {
		display: flex;
		flex-direction: column;
		gap: 6px;
	}

	.form-group label {
		font-weight: 500;
		color: #374151;
		font-size: 14px;
	}

	.form-group input,
	.form-group select {
		padding: 10px 12px;
		border: 1px solid #d1d5db;
		border-radius: 6px;
		font-size: 14px;
		transition: border-color 0.2s ease;
	}

	.form-group input:focus,
	.form-group select:focus {
		outline: none;
		border-color: #3b82f6;
		box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
	}

	.placeholder-field {
		opacity: 0.6;
	}

	.disabled-field {
		padding: 10px 12px;
		background: #f9fafb;
		border: 1px solid #e5e7eb;
		border-radius: 6px;
		color: #6b7280;
		font-style: italic;
		font-size: 14px;
	}

	.modal-footer {
		display: flex;
		justify-content: flex-end;
		gap: 12px;
		padding: 0 24px 24px 24px;
		border-top: 1px solid #e5e7eb;
		margin-top: 24px;
		padding-top: 24px;
	}

	.cancel-btn {
		padding: 10px 20px;
		border: 1px solid #d1d5db;
		background: white;
		color: #374151;
		border-radius: 6px;
		cursor: pointer;
		font-weight: 500;
		transition: all 0.2s ease;
	}

	.cancel-btn:hover {
		background: #f9fafb;
		border-color: #9ca3af;
	}

	.save-btn {
		padding: 10px 20px;
		background: #3b82f6;
		color: white;
		border: none;
		border-radius: 6px;
		cursor: pointer;
		font-weight: 500;
		transition: all 0.2s ease;
	}

	.save-btn:hover {
		background: #2563eb;
	}

	.actions-header {
		font-weight: 600;
		color: #374151;
		text-align: center;
	}

	.actions-cell {
		display: flex;
		justify-content: flex-start;
		align-items: center;
		padding: 8px 4px 8px 160px;
		min-width: 100px;
	}

	.reschedule-btn {
		padding: 6px 12px;
		background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
		color: white;
		border: none;
		border-radius: 6px;
		font-size: 11px;
		font-weight: 600;
		cursor: pointer;
		transition: all 0.2s ease;
		white-space: nowrap;
		box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2);
		display: inline-flex;
		align-items: center;
		gap: 4px;
	}

	.reschedule-btn:hover {
		background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
		transform: translateY(-1px);
		box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
	}

	.reschedule-btn:active {
		transform: translateY(0);
	}

	.reschedule-btn:disabled {
		background: #d1d5db;
		cursor: not-allowed;
		transform: none;
		box-shadow: none;
	}

	.paid-label {
		color: #10b981;
		font-weight: 600;
		font-size: 11px;
		padding: 4px 8px;
		background: rgba(16, 185, 129, 0.1);
		border-radius: 4px;
	}

	.date-input {
		padding: 8px 12px;
		border: 1px solid #d1d5db;
		border-radius: 6px;
		font-size: 14px;
		background: white;
		color: #374151;
		min-width: 150px;
	}

	.date-input:focus {
		outline: none;
		border-color: #3b82f6;
		box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
	}

	/* Responsive grid for Actions column */
	@media (max-width: 1400px) {
		.payment-header-row,
		.payment-data-row {
			grid-template-columns: 35px 120px 160px 90px 100px 100px 85px 85px 95px 120px 90px 140px 130px 70px 5px 130px 100px;
		}
	}

	@media (max-width: 768px) {
		.form-row {
			grid-template-columns: 1fr;
		}
		
		.edit-modal {
			width: 95%;
			margin: 20px;
		}
	}
</style>